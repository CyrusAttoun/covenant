//! Optimization pass infrastructure and implementations
//!
//! This module provides the `OptimizationPass` trait and concrete pass implementations.

pub mod constant_fold;
pub mod dead_code;
pub mod unused_binding;

pub use constant_fold::ConstantFolding;
pub use dead_code::DeadCodeElimination;
pub use unused_binding::UnusedBindingDetection;

use covenant_ast::Step;

/// Optimization level controlling which passes run
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Default)]
pub enum OptLevel {
    /// No optimization - useful for debugging
    #[default]
    O0,
    /// Basic optimizations (dead code detection, warnings only)
    O1,
    /// Standard optimizations (constant folding + dead code removal)
    O2,
    /// Aggressive optimizations (all passes)
    O3,
}

/// Settings for the optimizer
#[derive(Debug, Clone)]
pub struct OptSettings {
    /// Optimization level
    pub level: OptLevel,
    /// Whether to emit warnings about potential issues
    pub emit_warnings: bool,
}

impl Default for OptSettings {
    fn default() -> Self {
        Self {
            level: OptLevel::O0,
            emit_warnings: true,
        }
    }
}

/// Context passed to optimization passes
#[derive(Debug, Clone)]
pub struct OptContext {
    pub settings: OptSettings,
}

/// Result of running an optimization pass
#[derive(Debug, Clone, Default)]
pub struct PassResult {
    /// Whether the IR was modified
    pub modified: bool,
    /// Warnings generated during optimization
    pub warnings: Vec<OptWarning>,
}

/// A warning generated by an optimization pass
#[derive(Debug, Clone)]
pub struct OptWarning {
    /// Warning code (e.g., "W-DEAD-001")
    pub code: &'static str,
    /// Human-readable message
    pub message: String,
    /// Optional step ID where the warning occurred
    pub step_id: Option<String>,
}

/// Trait for optimization passes
pub trait OptimizationPass {
    /// Name of this pass for logging/debugging
    fn name(&self) -> &'static str;

    /// Run the optimization pass on the steps
    fn run(&self, steps: &mut Vec<Step>, ctx: &OptContext) -> PassResult;
}
