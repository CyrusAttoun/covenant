(* Covenant Grammar - Machine-First IR *)
(* Optimized for LLM generation: deterministic, tree-shaped, keyword-heavy *)
(* Every construct has an ID, canonical ordering, no operators *)

(* === Design Principles === *)
(*
   1. Everything is a block with kind, id, and explicit end
   2. No operators - use keywords: add, equals, and, or, not
   3. No expression nesting - one operation per step, named outputs (SSA)
   4. Strict canonical ordering - one valid way to write everything
   5. ~50-60 keywords total - small grammar surface area
   6. Double quotes only, // comments (ignored), note keyword (queryable)
   7. Data and code unified via relations - documentation links to functions
   8. Query dialects: covenant (default, typed) vs sql dialects (opaque body blocks)
*)

(* === Top Level === *)
program        = { top_level_item } ;
top_level_item = snippet | refactor_block ;

snippet        = "snippet" snippet_header { note_decl } { section } "end" ;
snippet_header = "id" "=" STRING "kind" "=" snippet_kind ;
snippet_kind   = "fn" | "struct" | "enum" | "module" | "database" | "extern" | "test" | "data" ;

(* === Refactor Block === *)
(* Multi-snippet transformations with transactional semantics *)
refactor_block = "refactor" "id" "=" STRING { step } "end" ;

(* === Notes (queryable annotations) === *)
(* Notes appear after snippet header, before sections *)
(* Unlike // comments which are ignored, notes are part of the AST and queryable *)
note_decl      = "note" [ note_lang ] ( STRING | TRIPLE_STRING ) ;
note_lang      = "lang" "=" STRING ;

(* === Sections (in canonical order) === *)
section        = effects_section
               | requires_section
               | types_section
               | tools_section
               | signature_section
               | body_section
               | tests_section
               | metadata_section
               | relations_section
               | content_section
               | schema_section ;

(* === Effects Section === *)
(* Declares capabilities this snippet requires *)
effects_section = "effects" { effect_decl } "end" ;
effect_decl     = "effect" effect_name [ effect_params ] ;
effect_name     = IDENT { "." IDENT } ;
effect_params   = "(" { effect_param } ")" ;
effect_param    = IDENT "=" value ;

(* === Requirements Section === *)
(* First-class specifications, queryable and linkable to tests *)
requires_section = "requires" { requirement } "end" ;
requirement      = "req" "id" "=" STRING { req_field } "end" ;
req_field        = "text" STRING
                 | "priority" ( "critical" | "high" | "medium" | "low" )
                 | "status" ( "draft" | "approved" | "implemented" | "tested" ) ;

(* === Types Section === *)
(* Type definitions local to this snippet *)
types_section  = "types" { type_def } "end" ;
type_def       = struct_def | enum_def | alias_def ;

struct_def     = "struct" "name" "=" STRING { struct_field } "end" ;
struct_field   = "field" "name" "=" STRING "type" "=" type_ref [ field_attrs ] ;
field_attrs    = { "optional" | "default" "=" value } ;

enum_def       = "enum" "name" "=" STRING { enum_variant } "end" ;
enum_variant   = "variant" "name" "=" STRING [ variant_data ] ;
variant_data   = "(" type_list ")" | "{" { struct_field } "}" ;

alias_def      = "alias" "name" "=" STRING "type" "=" type_ref ;

(* === Tools Section === *)
(* References to external tool contracts *)
tools_section  = "tools" { tool_ref } "end" ;
tool_ref       = "tool" "id" "=" STRING "contract" "=" STRING [ tool_attrs ] "end" ;
tool_attrs     = { "idempotent" "=" IDENT
                 | "timeout" "=" duration
                 | "retry" "=" retry_spec
                 | "auth" "=" STRING } ;
retry_spec     = "(" "max" "=" NUMBER "backoff" "=" ( "none" | "linear" | "exponential" ) ")" ;
duration       = NUMBER ( "ms" | "s" | "m" ) ;

(* === Signature Section === *)
(* Function, struct, or enum public interface *)
signature_section = "signature" signature_body "end" ;

signature_body = fn_signature | struct_signature | enum_signature ;

fn_signature   = "fn" "name" "=" STRING { fn_sig_part } "end" ;
fn_sig_part    = param_decl | returns_decl | generic_decl ;

param_decl     = "param" "name" "=" STRING "type" "=" type_ref [ param_attrs ] ;
param_attrs    = { "optional" | "default" "=" value } ;

returns_decl   = "returns" return_type "end" ;
return_type    = "type" "=" type_ref [ "optional" ]
               | "collection" "of" "=" type_ref
               | "union" { union_member } ;
union_member   = "type" "=" type_ref [ "optional" ] ;

generic_decl   = "generic" "name" "=" STRING [ "constraint" "=" type_ref ] ;

struct_signature = "struct" "name" "=" STRING { struct_field } "end" ;
enum_signature   = "enum" "name" "=" STRING { enum_variant } "end" ;

(* === Body Section === *)
(* Implementation as a sequence of steps (SSA form) *)
body_section   = "body" { step } "end" ;

step           = "step" "id" "=" STRING "kind" "=" step_kind step_body "as" "=" STRING "end" ;
step_kind      = "compute" | "call" | "query" | "bind" | "return"
               | "if" | "match" | "for" | "insert" | "update" | "delete"
               | "transaction" | "update_snippet" | "update_all"
               | "traverse" | "construct" | "parallel" | "race" ;

step_body      = compute_body | call_body | query_body | bind_body | return_body
               | if_body | match_body | for_body
               | insert_body | update_body | delete_body
               | transaction_body | update_snippet_body | update_all_body
               | traverse_body | construct_body | parallel_body | race_body ;

(* --- Compute: arithmetic and logic --- *)
compute_body   = "op" "=" binary_op input input
               | "op" "=" unary_op input
               | "op" "=" ternary_op input input input ;

binary_op      = (* Arithmetic *)
                 "add" | "sub" | "mul" | "div" | "mod"
                 (* Comparison *)
               | "equals" | "not_equals" | "less" | "greater" | "less_eq" | "greater_eq"
                 (* Logical *)
               | "and" | "or"
                 (* String (binary) *)
               | "concat" | "contains" | "starts_with" | "ends_with" | "index_of"
               | "replace" | "split" | "join" | "repeat" | "pad_start" | "pad_end"
                 (* Numeric (binary) *)
               | "min" | "max" | "clamp" | "pow"
                 (* Bitwise (binary) *)
               | "bit_and" | "bit_or" | "bit_xor" | "bit_shl" | "bit_shr" | "bit_ushr"
                 (* List (binary) *)
               | "list_get" | "list_append" | "list_prepend" | "list_concat"
               | "list_slice" | "list_take" | "list_drop" | "list_contains" | "list_index_of"
                 (* Map (binary) *)
               | "map_get" | "map_has" | "map_insert" | "map_remove" | "map_merge"
                 (* Set (binary) *)
               | "set_has" | "set_add" | "set_remove" | "set_union" | "set_intersect"
               | "set_diff" | "set_symmetric_diff" | "set_is_subset" | "set_is_superset"
                 (* DateTime (binary) *)
               | "dt_add_days" | "dt_add_hours" | "dt_add_minutes" | "dt_add_seconds" | "dt_diff" | "dt_format"
                 (* Bytes (binary) *)
               | "bytes_get" | "bytes_slice" | "bytes_concat" ;

unary_op       = (* Logical *)
                 "not" | "neg"
                 (* String (unary) *)
               | "str_len" | "byte_len" | "is_empty" | "upper" | "lower"
               | "trim" | "trim_start" | "trim_end" | "str_reverse" | "char_at"
                 (* Numeric (unary) *)
               | "abs" | "sqrt" | "floor" | "ceil" | "round" | "trunc" | "sign"
               | "bit_not"
                 (* Conversion *)
               | "to_int" | "to_float" | "to_string" | "parse_int" | "parse_float"
                 (* List (unary) *)
               | "list_len" | "list_first" | "list_last" | "list_reverse"
               | "list_is_empty" | "list_sort" | "list_dedup" | "list_flatten"
                 (* Map (unary) *)
               | "map_len" | "map_keys" | "map_values" | "map_entries" | "map_is_empty"
                 (* Set (unary) *)
               | "set_len" | "set_is_empty" | "set_to_list"
                 (* DateTime (unary) *)
               | "dt_year" | "dt_month" | "dt_day" | "dt_hour" | "dt_minute"
               | "dt_second" | "dt_weekday" | "dt_unix"
                 (* Bytes (unary) *)
               | "bytes_len" | "bytes_is_empty" | "bytes_to_string" | "bytes_to_base64" | "bytes_to_hex" ;

ternary_op     = "slice" | "clamp" | "replace" ; (* 3 inputs: slice(str, start, end), clamp(val, min, max), replace(str, find, repl) *)

input          = "input" input_source ;
input_source   = "var" "=" STRING
               | "lit" "=" literal
               | "field" "=" STRING "of" "=" STRING ;

(* --- Call: function or tool invocation --- *)
call_body      = ( "fn" "=" STRING | "tool" "=" STRING ) { call_arg } [ error_handler ] ;
call_arg       = "arg" "name" "=" STRING "from" "=" STRING ;
error_handler  = "handle" { handle_case } "end" ;
handle_case    = "case" "type" "=" type_ref { step } "end" ;

(* === Query Step === *)
(* Unified query with dialect attribute determining syntax *)
(*
   - dialect omitted or "covenant": structured Covenant query syntax (typed)
   - dialect = "postgres" | "sqlserver" | etc: opaque body block (raw SQL)

   Covenant dialect: minimal, LLM-friendly syntax for Covenant types
   SQL dialects: full SQL power via body block, compiler only validates param bindings
*)

query_body     = [ dialect_clause ] "target" "=" STRING query_content ;

(* Dialect declaration - determines body syntax *)
dialect_clause = "dialect" "=" dialect_value ;
dialect_value  = STRING ;   (* "covenant" | "postgres" | "sqlserver" | "mysql" | "sqlite" | "indexeddb" | etc *)

(* Query content depends on dialect *)
query_content  = covenant_query_content     (* When dialect omitted, "covenant", or "indexeddb" *)
               | dialect_query_content ;    (* When dialect is SQL: postgres, mysql, etc. *)

(* Note: "indexeddb" dialect uses covenant_query_content but compiles to
   IndexedDB (browser), SQLite (Node.js), or embedded DB (WASI).
   This provides cross-platform document storage with typed queries. *)

(* --- Covenant Dialect: Structured, Typed Queries --- *)
(* Simple syntax for querying Covenant types (project AST, structs, collections) *)
covenant_query_content =
    select_clause
    from_clause
    [ join_or_follow ]
    [ where_clause ]
    [ order_clause ]
    [ limit_clause ] ;

(* Simple select: all fields or specific fields *)
select_clause  = "select" ( "all" | { select_field } ) ;
select_field   = "field" "=" STRING ;

from_clause    = "from" "=" STRING ;

(* Join: explicit field join OR relation traversal *)
join_or_follow = join_clause | follow_clause ;

(* Explicit join on matching fields *)
join_clause    = "join" "to" "=" STRING "on" condition "end" ;

(* Follow declared relation (cleaner when relations are pre-declared) *)
follow_clause  = "follow" "rel" "=" STRING ;

(* Where: simple conditions only *)
where_clause   = "where" condition "end" ;

condition      = simple_condition | compound_condition | relation_condition ;

simple_condition = compare_op "field" "=" STRING ( "var" "=" STRING | "lit" "=" literal | "field" "=" STRING ) ;

compare_op     = "equals" | "not_equals" | "less" | "greater" | "less_eq" | "greater_eq" | "contains" ;

compound_condition = ( "and" | "or" ) { condition } "end"
                   | "not" condition ;

(* Relation conditions for querying by graph edges *)
relation_condition = "rel_to" "target" "=" STRING "type" "=" relation_type
                   | "rel_from" "source" "=" STRING "type" "=" relation_type
                   | "has_rel" "type" "=" relation_type ;

(* Order by single field *)
order_clause   = "order" "by" "=" STRING "dir" "=" ( "asc" | "desc" ) ;

(* Limit with optional offset *)
limit_clause   = "limit" "=" NUMBER [ "offset" "=" NUMBER ] ;

(* --- SQL Dialects: Opaque Body Block --- *)
(* For postgres, sqlserver, mysql, sqlite, lancedb, etc. *)
(* Compiler does NOT parse SQL - only validates parameter bindings *)
dialect_query_content =
    "body" RAW_BLOCK_CONTENT "end"
    [ params_section ]
    "returns" return_type_spec ;

(* Raw block content - everything between body and end keywords *)
(* Parser treats this as opaque text, passed directly to database driver *)
RAW_BLOCK_CONTENT = { any_char_except_end_keyword } ;

(* Parameter declarations - compiler validates against placeholders in body *)
(* Placeholder syntax per dialect: :name (postgres), @name (sqlserver), ? (mysql) *)
params_section = "params" { param_binding } "end" ;
param_binding  = "param" "name" "=" STRING "from" "=" STRING ;

(* Return type annotation - required for dialect queries *)
return_type_spec = "type" "=" type_ref
                 | "collection" "of" "=" type_ref
                 | "union" { union_member } "end" ;

(* --- Bind: variable binding --- *)
bind_body      = [ "mut" ] ( "from" "=" STRING | "lit" "=" literal ) ;

(* --- Return --- *)
return_body    = [ "from" "=" STRING ]
               | "lit" "=" literal
               | variant_constructor
               | struct_constructor ;

variant_constructor = "variant" "type" "=" STRING { constructor_field } "end" ;
struct_constructor  = "struct" "type" "=" STRING { constructor_field } "end" ;
constructor_field   = "field" "name" "=" STRING ( "from" "=" STRING | "lit" "=" literal ) ;

(* --- If --- *)
if_body        = "condition" "=" STRING "then" { step } [ "else" { step } ] ;

(* --- Match --- *)
match_body     = "on" "=" STRING { match_case } ;
match_case     = "case" pattern { step } "end" ;

pattern        = "wildcard"
               | "binding" "=" STRING
               | "literal" "=" literal
               | "variant" "type" "=" STRING [ "bindings" "=" "(" { STRING } ")" ]
               | "struct" "type" "=" STRING [ "fields" "=" "(" { STRING } ")" ] ;

(* --- For --- *)
for_body       = "var" "=" STRING "in" "=" STRING { step } ;

(* --- Insert: Covenant types only --- *)
insert_body    = "into" "=" STRING { field_value } ;
field_value    = "set" "field" "=" STRING ( "from" "=" STRING | "lit" "=" literal ) ;

(* --- Update: Covenant types only --- *)
update_body    = "target" "=" STRING { field_value } [ where_clause ] ;

(* --- Delete: Covenant types only --- *)
delete_body    = "from" "=" STRING [ where_clause ] ;

(* --- Transaction: wraps multiple steps for atomicity --- *)
transaction_body = [ "isolation" "=" isolation_level ] { step } ;
isolation_level  = "read_uncommitted" | "read_committed" | "repeatable_read" | "serializable" ;

(* --- Update Snippet: modify snippet metadata (for refactoring) --- *)
update_snippet_body = "target" "=" STRING { field_value } ;

(* --- Update All: batch update from query results --- *)
update_all_body = "target" "=" STRING { field_value } ;

(* --- Traverse: graph traversal for relations --- *)
(* Follows relation edges transitively from a starting node *)
traverse_body  = "target" "=" STRING
                 "from" "=" STRING
                 "follow" "type" "=" relation_type
                 [ "depth" "=" ( NUMBER | "unbounded" ) ]
                 [ "direction" "=" ( "outgoing" | "incoming" | "both" ) ]
                 [ where_clause ] ;

(* --- Construct: build struct or collection from fields --- *)
construct_body = "struct" { constructor_field } "end"
               | "collection" { collection_item } "end" ;
collection_item = "item" ( "from" "=" STRING | "lit" "=" literal ) ;

(* --- Parallel: execute branches concurrently, wait for all --- *)
parallel_body  = [ parallel_attrs ] { branch_def } ;
parallel_attrs = { "on_error" "=" ( "fail_fast" | "collect_all" | "ignore_errors" )
                 | "timeout" "=" duration
                 | "on_timeout" "=" ( "cancel" | "return_partial" ) } ;

(* --- Race: execute branches concurrently, return first to complete --- *)
race_body      = [ "timeout" "=" duration ] { branch_def } ;

(* Branch: execution unit within parallel/race steps *)
branch_def     = "branch" "id" "=" STRING { step } "end" ;

(* === Tests Section === *)
(* Test definitions linked to requirements *)
tests_section  = "tests" { test_def } "end" ;
test_def       = "test" "id" "=" STRING test_attrs { step } "end" ;
test_attrs     = { "kind" "=" test_kind
                 | "covers" "=" STRING
                 | "property" "=" STRING } ;
test_kind      = "unit" | "property" | "integration" | "golden" ;

(* === Metadata Section === *)
(* Additional metadata for AI planning *)
metadata_section = "metadata" { meta_field } "end" ;
meta_field     = "author" "=" STRING
               | "created" "=" STRING
               | "modified" "=" STRING
               | "confidence" "=" NUMBER
               | "provenance" "=" STRING
               | "cost_hint" "=" ( "cheap" | "moderate" | "expensive" )
               | "latency_hint" "=" ( "fast" | "medium" | "slow" )
               | "tags" "=" array_literal
               | "generated_by" "=" STRING
               | "human_reviewed" "=" ( "true" | "false" )
               (* Extended metadata for database bindings *)
               | "type" "=" STRING
               | "dialect" "=" STRING
               | "connection" "=" STRING
               | "version" "=" STRING
               | "contract" "=" STRING ;

(* === Relations Section === *)
(* Semantic relationships between snippets - data and code unified *)
(* Compiler auto-maintains inverse relations (Invariant I5) *)
relations_section = "relations" { relation_decl } "end" ;
relation_decl  = "rel" relation_dir "=" STRING "type" "=" relation_type ;
relation_dir   = "to" | "from" ;

(* Fixed vocabulary of relation types - extensible in future versions *)
relation_type  = (* Structural *)
                 "contains" | "contained_by" | "next" | "previous"
                 (* Semantic *)
               | "describes" | "described_by" | "elaborates_on" | "contrasts_with" | "example_of"
                 (* Temporal *)
               | "supersedes" | "precedes" | "version_of"
                 (* Causal *)
               | "causes" | "caused_by" | "motivates" | "enables"
                 (* Reference *)
               | "related_to" | "depends_on" | "implements" | "implemented_by" ;

(* === Content Section === *)
(* For kind="data" snippets: the actual data content *)
(* Can be schema-free (flexible) or validated against optional schema *)
content_section = "content" content_body "end" ;
content_body   = STRING | TRIPLE_STRING | { content_field } ;
content_field  = IDENT ( STRING | TRIPLE_STRING | literal | struct_literal ) ;

(* === Schema Section === *)
(* Schema for data snippets and database bindings *)
schema_section = "schema" schema_content "end" ;
schema_content = { schema_item } ;
schema_item    = schema_field | table_def ;
schema_field   = "field" "name" "=" STRING "type" "=" type_ref [ field_modifiers ] ;
field_modifiers = { "optional" | "primary_key" "=" ( "true" | "false" ) } ;

(* Table definitions for database bindings *)
table_def      = "table" "name" "=" STRING { table_field } "end" ;
table_field    = "field" "name" "=" STRING "type" "=" type_ref [ field_modifiers ] ;


(* === Type References === *)
type_ref       = type_path [ type_modifiers ] ;
type_path      = IDENT { "::" IDENT } ;
type_modifiers = { "?" | "[]" | "<" type_list ">" } ;
type_list      = type_ref { "," type_ref } ;

(* === Values and Literals === *)
value          = literal | "var" "=" STRING ;
literal        = NUMBER [ ":" type_ref ]
               | STRING
               | "true" | "false"
               | "none"
               | array_literal
               | struct_literal ;

array_literal  = "[" [ literal { "," literal } ] "]" ;
struct_literal = "{" [ struct_field_lit { "," struct_field_lit } ] "}" ;
struct_field_lit = STRING ":" literal ;

(* === Tokens === *)
IDENT          = letter { letter | digit | "_" } ;
NUMBER         = digit { digit } [ "." digit { digit } ] ;
STRING         = '"' { any_char_except_quote | escape_seq } '"' ;
TRIPLE_STRING  = '"""' { any_char | newline } '"""' ;   (* Multi-line string, Python-style *)
escape_seq     = "\\" ( '"' | "\\" | "n" | "t" | "r" | "u" hex hex hex hex ) ;

(* === Comments === *)
(* // single line comment *)
COMMENT        = "//" { any_char_except_newline } NEWLINE ;

(* === Reserved Keywords (canonical list) === *)
(*
   Blocks: snippet, end, effects, requires, types, tools, signature, body, tests, metadata, refactor, relations, content, schema
   Snippet Kinds: fn, struct, enum, module, database, extern, test, data
   Types: struct, enum, alias, field, variant, fn, param, returns, union, generic, type, collection, of
   Effects: effect
   Requirements: req, text, priority, status
   Tools: tool, contract, idempotent, timeout, retry, auth
   Steps: step, kind, as, op, input, var, lit, from, of, into, set, construct, item
   Operators (core): add, sub, mul, div, mod, equals, not_equals, less, greater, less_eq, greater_eq, and, or, not, neg, concat, contains
   Operators (string): slice, upper, lower, trim, trim_start, trim_end, replace, split, join, repeat, str_len, byte_len, is_empty, starts_with, ends_with, index_of, char_at, str_reverse, pad_start, pad_end
   Operators (numeric): abs, min, max, clamp, pow, sqrt, floor, ceil, round, trunc, sign
   Operators (bitwise): bit_and, bit_or, bit_xor, bit_not, bit_shl, bit_shr, bit_ushr
   Operators (conversion): to_int, to_float, to_string, parse_int, parse_float
   Operators (list): list_len, list_get, list_first, list_last, list_append, list_prepend, list_concat, list_slice, list_reverse, list_take, list_drop, list_contains, list_index_of, list_is_empty, list_sort, list_dedup, list_flatten
   Operators (map): map_len, map_get, map_has, map_insert, map_remove, map_keys, map_values, map_entries, map_merge, map_is_empty
   Operators (set): set_len, set_has, set_add, set_remove, set_union, set_intersect, set_diff, set_symmetric_diff, set_is_subset, set_is_superset, set_is_empty, set_to_list
   Operators (datetime): dt_year, dt_month, dt_day, dt_hour, dt_minute, dt_second, dt_weekday, dt_unix, dt_add_days, dt_add_hours, dt_add_minutes, dt_add_seconds, dt_diff, dt_format
   Operators (bytes): bytes_len, bytes_get, bytes_slice, bytes_concat, bytes_to_string, bytes_to_base64, bytes_to_hex, bytes_is_empty
   Control: if, then, else, match, case, for, in, return, bind, mut
   Query: query, target, select, all, from, join, to, on, where, order, by, dir, asc, desc, limit, offset, follow, rel
   Dialects: dialect (value is freeform string for extensibility)
   Query Params: params, param, name
   CRUD: insert, update, delete
   Transaction: transaction, isolation, read_uncommitted, read_committed, repeatable_read, serializable
   Refactoring: update_snippet, update_all
   Tests: test, covers, property, unit, integration, golden
   Metadata: author, created, modified, confidence, provenance, cost_hint, latency_hint, cheap, moderate, expensive, fast, medium, slow, tags, generated_by, human_reviewed, connection, version
   Literals: true, false, none
   Modifiers: optional, default, constraint, handle, wildcard, binding, literal, primary_key, multiple, required, values
   Notes: note, lang
   Concurrency: parallel, race, branch, on_error, fail_fast, collect_all, ignore_errors, on_timeout, cancel, return_partial
   Relations: rel, to, from, type, contains, contained_by, next, previous, describes, described_by, elaborates_on, contrasts_with, example_of, supersedes, precedes, version_of, causes, caused_by, motivates, enables, related_to, depends_on, implements, implemented_by
   Traversal: traverse, follow, depth, unbounded, direction, outgoing, incoming, both
   Relation Queries: rel_to, rel_from, has_rel, source
   Schema: table, primary_key
*)
