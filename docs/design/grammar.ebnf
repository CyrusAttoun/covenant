(* Covenant Grammar - Machine-First IR *)
(* Optimized for LLM generation: deterministic, tree-shaped, keyword-heavy *)
(* Every construct has an ID, canonical ordering, no operators *)

(* === Design Principles === *)
(*
   1. Everything is a block with kind, id, and explicit end
   2. No operators - use keywords: add, equals, and, or, not
   3. No expression nesting - one operation per step, named outputs (SSA)
   4. Strict canonical ordering - one valid way to write everything
   5. ~50-60 keywords total - small grammar surface area
   6. Double quotes only, // comments (ignored), note keyword (queryable)
   7. Data and code unified via relations - documentation links to functions
   8. Query dialects: covenant (default, typed) vs sql dialects (opaque body blocks)
*)

(* === Top Level === *)
program        = { top_level_item } ;
top_level_item = snippet | refactor_block ;

snippet        = "snippet" snippet_header { note_decl } { section } "end" ;
snippet_header = "id" "=" STRING "kind" "=" snippet_kind ;
snippet_kind   = "fn" | "struct" | "enum" | "module" | "database" | "extern" | "test" | "data" | "effect-kind" ;

(* === Refactor Block === *)
(* Multi-snippet transformations with transactional semantics *)
refactor_block = "refactor" "id" "=" STRING { step } "end" ;

(* === Notes (queryable annotations) === *)
(* Notes appear after snippet header, before sections *)
(* Unlike // comments which are ignored, notes are part of the AST and queryable *)
note_decl      = "note" [ note_lang ] ( STRING | TRIPLE_STRING ) ;
note_lang      = "lang" "=" STRING ;

(* === Sections (in canonical order) === *)
section        = effects_section
               | requires_section
               | types_section
               | tools_section
               | signature_section
               | body_section
               | tests_section
               | metadata_section
               | relations_section
               | content_section
               | schema_section
               | kinds_section
               | effects_required_section ;

(* === Effects Section === *)
(* Declares capabilities this snippet requires *)
effects_section = "effects" { effect_decl } "end" ;
effect_decl     = "effect" IDENT [ effect_params ] ;
effect_params   = "(" { effect_param } ")" ;
effect_param    = IDENT "=" value ;

(* === Requirements Section === *)
(* First-class specifications, queryable and linkable to tests *)
requires_section = "requires" { requirement } "end" ;
requirement      = "req" "id" "=" STRING { req_field } "end" ;
req_field        = "text" STRING
                 | "priority" ( "critical" | "high" | "medium" | "low" )
                 | "status" ( "draft" | "approved" | "implemented" | "tested" ) ;

(* === Types Section === *)
(* Type definitions local to this snippet *)
types_section  = "types" { type_def } "end" ;
type_def       = struct_def | enum_def | alias_def ;

struct_def     = "struct" "name" "=" STRING { struct_field } "end" ;
struct_field   = "field" "name" "=" STRING "type" "=" type_ref [ field_attrs ] ;
field_attrs    = { "optional" | "default" "=" value } ;

enum_def       = "enum" "name" "=" STRING { enum_variant } "end" ;
enum_variant   = "variant" "name" "=" STRING [ variant_data ] ;
variant_data   = "(" type_list ")" | "{" { struct_field } "}" ;

alias_def      = "alias" "name" "=" STRING "type" "=" type_ref ;

(* === Tools Section === *)
(* References to external tool contracts *)
tools_section  = "tools" { tool_ref } "end" ;
tool_ref       = "tool" "id" "=" STRING "contract" "=" STRING [ tool_attrs ] "end" ;
tool_attrs     = { "idempotent" "=" IDENT
                 | "timeout" "=" duration
                 | "retry" "=" retry_spec
                 | "auth" "=" STRING } ;
retry_spec     = "(" "max" "=" NUMBER "backoff" "=" ( "none" | "linear" | "exponential" ) ")" ;
duration       = NUMBER ( "ms" | "s" | "m" ) ;

(* === Signature Section === *)
(* Function, struct, or enum public interface *)
signature_section = "signature" signature_body "end" ;

signature_body = fn_signature | struct_signature | enum_signature ;

fn_signature   = "fn" "name" "=" STRING { fn_sig_part } "end" ;
fn_sig_part    = param_decl | returns_decl | generic_decl ;

param_decl     = "param" "name" "=" STRING "type" "=" type_ref [ param_attrs ] ;
param_attrs    = { "optional" | "default" "=" value } ;

returns_decl   = "returns" return_type "end" ;
return_type    = "type" "=" type_ref [ "optional" ]
               | "collection" "of" "=" type_ref
               | "union" { union_member } ;
union_member   = "type" "=" type_ref [ "optional" ] ;

generic_decl   = "generic" "name" "=" STRING [ "constraint" "=" type_ref ] ;

struct_signature = "struct" "name" "=" STRING { struct_field } "end" ;
enum_signature   = "enum" "name" "=" STRING { enum_variant } "end" ;

(* === Body Section === *)
(* Implementation as a sequence of steps (SSA form) *)
body_section   = "body" { step } "end" ;

step           = "step" "id" "=" STRING "kind" "=" step_kind step_body "as" "=" STRING "end" ;
step_kind      = core_step_kind | extended_step_kind ;

(* Core step kinds - built-in, no import needed *)
core_step_kind = "compute" | "call" | "query" | "bind" | "return"
               | "if" | "match" | "for" | "insert" | "update" | "delete"
               | "transaction" | "update_snippet" | "update_all"
               | "traverse" | "construct" ;

(* Extended step kinds - imported via effects, namespaced *)
(* Examples: std.concurrent.parallel, std.concurrent.race, acme.workflow.approval *)
extended_step_kind = IDENT "." IDENT "." IDENT ;

step_body      = compute_body | call_body | query_body | bind_body | return_body
               | if_body | match_body | for_body
               | insert_body | update_body | delete_body
               | transaction_body | update_snippet_body | update_all_body
               | traverse_body | construct_body | extended_step_body ;

(* --- Compute: arithmetic and logic --- *)
compute_body   = "op" "=" binary_op input input
               | "op" "=" unary_op input ;

binary_op      = "add" | "sub" | "mul" | "div" | "mod"
               | "equals" | "not_equals" | "less" | "greater" | "less_eq" | "greater_eq"
               | "and" | "or"
               | "concat" | "contains" ;

unary_op       = "not" | "neg" ;

input          = "input" input_source ;
input_source   = "var" "=" STRING
               | "lit" "=" literal
               | "field" "=" STRING "of" "=" STRING ;

(* --- Call: function or tool invocation --- *)
call_body      = ( "fn" "=" STRING | "tool" "=" STRING ) { call_arg } [ error_handler ] ;
call_arg       = "arg" "name" "=" STRING "from" "=" STRING ;
error_handler  = "handle" { handle_case } "end" ;
handle_case    = "case" "type" "=" type_ref { step } "end" ;

(* === Query Step === *)
(* Unified query with dialect attribute determining syntax *)
(*
   - dialect omitted or "covenant": structured Covenant query syntax (typed)
   - dialect = "postgres" | "sqlserver" | etc: opaque body block (raw SQL)

   Covenant dialect: minimal, LLM-friendly syntax for Covenant types
   SQL dialects: full SQL power via body block, compiler only validates param bindings
*)

query_body     = [ dialect_clause ] "target" "=" STRING query_content ;

(* Dialect declaration - determines body syntax *)
dialect_clause = "dialect" "=" dialect_value ;
dialect_value  = STRING ;   (* "covenant" | "postgres" | "sqlserver" | "mysql" | "sqlite" | etc *)

(* Query content depends on dialect *)
query_content  = covenant_query_content     (* When dialect omitted or "covenant" *)
               | dialect_query_content ;    (* When dialect is SQL or other *)

(* --- Covenant Dialect: Structured, Typed Queries --- *)
(* Simple syntax for querying Covenant types (project AST, structs, collections) *)
covenant_query_content =
    select_clause
    from_clause
    [ join_or_follow ]
    [ where_clause ]
    [ order_clause ]
    [ limit_clause ] ;

(* Simple select: all fields or specific fields *)
select_clause  = "select" ( "all" | { select_field } ) ;
select_field   = "field" "=" STRING ;

from_clause    = "from" "=" STRING ;

(* Join: explicit field join OR relation traversal *)
join_or_follow = join_clause | follow_clause ;

(* Explicit join on matching fields *)
join_clause    = "join" "to" "=" STRING "on" condition "end" ;

(* Follow declared relation (cleaner when relations are pre-declared) *)
follow_clause  = "follow" "rel" "=" STRING ;

(* Where: simple conditions only *)
where_clause   = "where" condition "end" ;

condition      = simple_condition | compound_condition | relation_condition ;

simple_condition = compare_op "field" "=" STRING ( "var" "=" STRING | "lit" "=" literal | "field" "=" STRING ) ;

compare_op     = "equals" | "not_equals" | "less" | "greater" | "less_eq" | "greater_eq" | "contains" ;

compound_condition = ( "and" | "or" ) { condition } "end"
                   | "not" condition ;

(* Relation conditions for querying by graph edges *)
relation_condition = "rel_to" "target" "=" STRING "type" "=" relation_type
                   | "rel_from" "source" "=" STRING "type" "=" relation_type
                   | "has_rel" "type" "=" relation_type ;

(* Order by single field *)
order_clause   = "order" "by" "=" STRING "dir" "=" ( "asc" | "desc" ) ;

(* Limit with optional offset *)
limit_clause   = "limit" "=" NUMBER [ "offset" "=" NUMBER ] ;

(* --- SQL Dialects: Opaque Body Block --- *)
(* For postgres, sqlserver, mysql, sqlite, lancedb, etc. *)
(* Compiler does NOT parse SQL - only validates parameter bindings *)
dialect_query_content =
    "body" RAW_BLOCK_CONTENT "end"
    [ params_section ]
    "returns" return_type_spec ;

(* Raw block content - everything between body and end keywords *)
(* Parser treats this as opaque text, passed directly to database driver *)
RAW_BLOCK_CONTENT = { any_char_except_end_keyword } ;

(* Parameter declarations - compiler validates against placeholders in body *)
(* Placeholder syntax per dialect: :name (postgres), @name (sqlserver), ? (mysql) *)
params_section = "params" { param_binding } "end" ;
param_binding  = "param" "name" "=" STRING "from" "=" STRING ;

(* Return type annotation - required for dialect queries *)
return_type_spec = "type" "=" type_ref
                 | "collection" "of" "=" type_ref
                 | "union" { union_member } "end" ;

(* --- Bind: variable binding --- *)
bind_body      = [ "mut" ] ( "from" "=" STRING | "lit" "=" literal ) ;

(* --- Return --- *)
return_body    = [ "from" "=" STRING ]
               | "lit" "=" literal
               | variant_constructor
               | struct_constructor ;

variant_constructor = "variant" "type" "=" STRING { constructor_field } "end" ;
struct_constructor  = "struct" "type" "=" STRING { constructor_field } "end" ;
constructor_field   = "field" "name" "=" STRING ( "from" "=" STRING | "lit" "=" literal ) ;

(* --- If --- *)
if_body        = "condition" "=" STRING "then" { step } [ "else" { step } ] ;

(* --- Match --- *)
match_body     = "on" "=" STRING { match_case } ;
match_case     = "case" pattern { step } "end" ;

pattern        = "wildcard"
               | "binding" "=" STRING
               | "literal" "=" literal
               | "variant" "type" "=" STRING [ "bindings" "=" "(" { STRING } ")" ]
               | "struct" "type" "=" STRING [ "fields" "=" "(" { STRING } ")" ] ;

(* --- For --- *)
for_body       = "var" "=" STRING "in" "=" STRING { step } ;

(* --- Insert: Covenant types only --- *)
insert_body    = "into" "=" STRING { field_value } ;
field_value    = "set" "field" "=" STRING ( "from" "=" STRING | "lit" "=" literal ) ;

(* --- Update: Covenant types only --- *)
update_body    = "target" "=" STRING { field_value } [ where_clause ] ;

(* --- Delete: Covenant types only --- *)
delete_body    = "from" "=" STRING [ where_clause ] ;

(* --- Transaction: wraps multiple steps for atomicity --- *)
transaction_body = [ "isolation" "=" isolation_level ] { step } ;
isolation_level  = "read_uncommitted" | "read_committed" | "repeatable_read" | "serializable" ;

(* --- Update Snippet: modify snippet metadata (for refactoring) --- *)
update_snippet_body = "target" "=" STRING { field_value } ;

(* --- Update All: batch update from query results --- *)
update_all_body = "target" "=" STRING { field_value } ;

(* --- Traverse: graph traversal for relations --- *)
(* Follows relation edges transitively from a starting node *)
traverse_body  = "target" "=" STRING
                 "from" "=" STRING
                 "follow" "type" "=" relation_type
                 [ "depth" "=" ( NUMBER | "unbounded" ) ]
                 [ "direction" "=" ( "outgoing" | "incoming" | "both" ) ]
                 [ where_clause ] ;

(* --- Construct: build struct or collection from fields --- *)
construct_body = "struct" { constructor_field } "end"
               | "collection" { collection_item } "end" ;
collection_item = "item" ( "from" "=" STRING | "lit" "=" literal ) ;

(* --- Extended Step Body: for kinds imported via effects --- *)
(* Structure is validated against the kind definition, not the grammar *)
(* Common patterns: branch-based (parallel, race), stage-based (workflow) *)
extended_step_body = { extended_step_attr } { branch_def } ;

extended_step_attr = "on_error" "=" ( "fail_fast" | "collect_all" | "ignore_errors" )
                   | "timeout" "=" duration
                   | "on_timeout" "=" ( "cancel" | "return_partial" ) ;

(* Branch: parallel execution unit within extended steps *)
branch_def     = "branch" "id" "=" STRING { step } "end" ;

(* === Tests Section === *)
(* Test definitions linked to requirements *)
tests_section  = "tests" { test_def } "end" ;
test_def       = "test" "id" "=" STRING test_attrs { step } "end" ;
test_attrs     = { "kind" "=" test_kind
                 | "covers" "=" STRING
                 | "property" "=" STRING } ;
test_kind      = "unit" | "property" | "integration" | "golden" ;

(* === Metadata Section === *)
(* Additional metadata for AI planning *)
metadata_section = "metadata" { meta_field } "end" ;
meta_field     = "author" "=" STRING
               | "created" "=" STRING
               | "modified" "=" STRING
               | "confidence" "=" NUMBER
               | "provenance" "=" STRING
               | "cost_hint" "=" ( "cheap" | "moderate" | "expensive" )
               | "latency_hint" "=" ( "fast" | "medium" | "slow" )
               | "tags" "=" array_literal
               | "generated_by" "=" STRING
               | "human_reviewed" "=" ( "true" | "false" )
               (* Extended metadata for database bindings *)
               | "type" "=" STRING
               | "dialect" "=" STRING
               | "connection" "=" STRING
               | "version" "=" STRING
               | "contract" "=" STRING ;

(* === Relations Section === *)
(* Semantic relationships between snippets - data and code unified *)
(* Compiler auto-maintains inverse relations (Invariant I5) *)
relations_section = "relations" { relation_decl } "end" ;
relation_decl  = "rel" relation_dir "=" STRING "type" "=" relation_type ;
relation_dir   = "to" | "from" ;

(* Fixed vocabulary of relation types - extensible in future versions *)
relation_type  = (* Structural *)
                 "contains" | "contained_by" | "next" | "previous"
                 (* Semantic *)
               | "describes" | "described_by" | "elaborates_on" | "contrasts_with" | "example_of"
                 (* Temporal *)
               | "supersedes" | "precedes" | "version_of"
                 (* Causal *)
               | "causes" | "caused_by" | "motivates" | "enables"
                 (* Reference *)
               | "related_to" | "depends_on" | "implements" | "implemented_by" ;

(* === Content Section === *)
(* For kind="data" snippets: the actual data content *)
(* Can be schema-free (flexible) or validated against optional schema *)
content_section = "content" content_body "end" ;
content_body   = STRING | TRIPLE_STRING | { content_field } ;
content_field  = IDENT ( STRING | TRIPLE_STRING | literal | struct_literal ) ;

(* === Schema Section === *)
(* Schema for data snippets and database bindings *)
schema_section = "schema" schema_content "end" ;
schema_content = { schema_item } ;
schema_item    = schema_field | table_def ;
schema_field   = "field" "name" "=" STRING "type" "=" type_ref [ field_modifiers ] ;
field_modifiers = { "optional" | "primary_key" "=" ( "true" | "false" ) } ;

(* Table definitions for database bindings *)
table_def      = "table" "name" "=" STRING { table_field } "end" ;
table_field    = "field" "name" "=" STRING "type" "=" type_ref [ field_modifiers ] ;

(* === Kinds Section (for effect-kind snippets) === *)
(* Defines new step or snippet kinds that can be imported via effects *)
kinds_section  = "kinds" { kind_def } "end" ;
kind_def       = "kind" "name" "=" STRING { note_decl } kind_structure [ kind_semantics ] "compile_to" "=" STRING "end" ;

kind_structure = "structure" { kind_structure_item } "end" ;
kind_structure_item = kind_section_def | kind_field_def ;

kind_section_def = "section" "name" "=" STRING { kind_section_attr } [ kind_contains ] "end" ;
kind_section_attr = "multiple" "=" ( "true" | "false" )
                  | "required" "=" ( "true" | "false" ) ;
kind_contains  = "contains" "kind" "=" STRING ;

kind_field_def = "field" "name" "=" STRING "type" "=" kind_field_type [ kind_field_attrs ] ;
kind_field_type = "String" | "Int" | "Bool" | "Duration" | "Enum" ;
kind_field_attrs = { "optional" "=" ( "true" | "false" )
                   | "required" "=" ( "true" | "false" )
                   | "default" "=" literal
                   | "values" "=" array_literal } ;

kind_semantics = "semantics" { kind_semantic_attr } "end" ;
kind_semantic_attr = IDENT "=" ( literal | IDENT ) ;

(* === Effects Required Section (for effect-kind snippets) === *)
(* Declares effects that users of this kind must have *)
effects_required_section = "effects_required" { effect_decl } "end" ;

(* === Type References === *)
type_ref       = type_path [ type_modifiers ] ;
type_path      = IDENT { "::" IDENT } ;
type_modifiers = { "?" | "[]" | "<" type_list ">" } ;
type_list      = type_ref { "," type_ref } ;

(* === Values and Literals === *)
value          = literal | "var" "=" STRING ;
literal        = NUMBER [ ":" type_ref ]
               | STRING
               | "true" | "false"
               | "none"
               | array_literal
               | struct_literal ;

array_literal  = "[" [ literal { "," literal } ] "]" ;
struct_literal = "{" [ struct_field_lit { "," struct_field_lit } ] "}" ;
struct_field_lit = STRING ":" literal ;

(* === Tokens === *)
IDENT          = letter { letter | digit | "_" } ;
NUMBER         = digit { digit } [ "." digit { digit } ] ;
STRING         = '"' { any_char_except_quote | escape_seq } '"' ;
TRIPLE_STRING  = '"""' { any_char | newline } '"""' ;   (* Multi-line string, Python-style *)
escape_seq     = "\\" ( '"' | "\\" | "n" | "t" | "r" | "u" hex hex hex hex ) ;

(* === Comments === *)
(* // single line comment *)
COMMENT        = "//" { any_char_except_newline } NEWLINE ;

(* === Reserved Keywords (canonical list) === *)
(*
   Blocks: snippet, end, effects, requires, types, tools, signature, body, tests, metadata, refactor, relations, content, schema, kinds, effects_required
   Snippet Kinds: fn, struct, enum, module, database, extern, test, data, effect-kind
   Types: struct, enum, alias, field, variant, fn, param, returns, union, generic, type, collection, of
   Effects: effect
   Requirements: req, text, priority, status
   Tools: tool, contract, idempotent, timeout, retry, auth
   Steps: step, kind, as, op, input, var, lit, from, of, into, set, construct, item
   Operators: add, sub, mul, div, mod, equals, not_equals, less, greater, less_eq, greater_eq, and, or, not, neg, concat, contains
   Control: if, then, else, match, case, for, in, return, bind, mut
   Query: query, target, select, all, from, join, to, on, where, order, by, dir, asc, desc, limit, offset, follow, rel
   Dialects: dialect (value is freeform string for extensibility)
   Query Params: params, param, name
   CRUD: insert, update, delete
   Transaction: transaction, isolation, read_uncommitted, read_committed, repeatable_read, serializable
   Refactoring: update_snippet, update_all
   Tests: test, covers, property, unit, integration, golden
   Metadata: author, created, modified, confidence, provenance, cost_hint, latency_hint, cheap, moderate, expensive, fast, medium, slow, tags, generated_by, human_reviewed, connection, version
   Literals: true, false, none
   Modifiers: optional, default, constraint, handle, wildcard, binding, literal, primary_key, multiple, required, values
   Notes: note, lang
   Kind Definitions: kinds, structure, section, contains, semantics, compile_to
   Concurrency: branch, on_error, fail_fast, collect_all, ignore_errors, on_timeout, cancel, return_partial
   Relations: rel, to, from, type, contains, contained_by, next, previous, describes, described_by, elaborates_on, contrasts_with, example_of, supersedes, precedes, version_of, causes, caused_by, motivates, enables, related_to, depends_on, implements, implemented_by
   Traversal: traverse, follow, depth, unbounded, direction, outgoing, incoming, both
   Relation Queries: rel_to, rel_from, has_rel, source
   Schema: table, primary_key
*)
