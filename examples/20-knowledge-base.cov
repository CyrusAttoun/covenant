// Example 20: Knowledge Base Traversal
//
// Demonstrates:
// - Building a queryable knowledge base with Covenant
// - Graph traversal using the traverse step
// - Querying relations between nodes
// - Managing hierarchical documentation

// -----------------------------------------------------------------------------
// Knowledge Base Root
// -----------------------------------------------------------------------------

snippet id="kb.root" kind="data"

  note "Root of the knowledge base hierarchy"

  content
    """
    Covenant Language Knowledge Base

    This knowledge base contains all documentation, specifications,
    and design decisions for the Covenant programming language.
    """
  end

  relations
    rel to="kb.design" type=contains
    rel to="kb.tutorials" type=contains
    rel to="kb.reference" type=contains
    rel to="kb.faq" type=contains
  end

end

// -----------------------------------------------------------------------------
// Design Section
// -----------------------------------------------------------------------------

snippet id="kb.design" kind="data"

  note "Design philosophy and architecture"

  content
    """
    # Design Documentation

    Core design principles and architectural decisions
    for the Covenant language.
    """
  end

  relations
    rel to="kb.design.philosophy" type=contains
    rel to="kb.design.four_layers" type=contains
    rel to="kb.design.effects" type=contains
    rel from="kb.root" type=contained_by
  end

end

snippet id="kb.design.philosophy" kind="data"

  note "Core design philosophy"

  content
    """
    # Design Philosophy

    Covenant is **machine-first**, not human-first.

    > Natural language is for requesting.
    > IR is for meaning.
    > Symbol graph is for querying.
    > Bytecode is for execution.

    The IR is the source of truth. Human-readable views
    are derived, not stored.
    """
  end

  relations
    rel from="kb.design" type=contained_by
    rel to="kb.design.four_layers" type=elaborates_on
  end

end

snippet id="kb.design.four_layers" kind="data"

  note "The four-layer model"

  content
    """
    # The Four-Layer Model

    1. **Natural Language** - Ephemeral, for requesting
    2. **IR** - Machine-readable source of truth
    3. **Symbol Graph** - Queryable, bidirectional
    4. **Bytecode** - WASM, sandboxed execution

    Each layer serves a specific purpose.
    """
  end

  relations
    rel from="kb.design" type=contained_by
    rel from="kb.design.philosophy" type=elaborates_on
    rel to="kb.faq.why_ir" type=example_of
  end

end

snippet id="kb.design.effects" kind="data"

  note "Effect system documentation"

  content
    """
    # Effect System

    Effects declare capabilities:
    - `database` - Database access
    - `network` - Network I/O
    - `filesystem` - File system access
    - `meta` - AST modification

    Effects propagate transitively through call graph.
    Pure functions (no effects) cannot call effectful code.
    """
  end

  relations
    rel from="kb.design" type=contained_by
    rel to="effects.database" type=describes
    rel to="effects.network" type=describes
  end

end

// -----------------------------------------------------------------------------
// FAQ Section
// -----------------------------------------------------------------------------

snippet id="kb.faq" kind="data"

  note "Frequently asked questions"

  content
    """
    # Frequently Asked Questions

    Common questions about Covenant.
    """
  end

  relations
    rel to="kb.faq.why_ir" type=contains
    rel to="kb.faq.why_no_operators" type=contains
    rel from="kb.root" type=contained_by
  end

end

snippet id="kb.faq.why_ir" kind="data"

  note "Why use an IR instead of natural language?"

  content
    """
    ## Why use an IR instead of natural language?

    **Q:** Why not just use natural language for everything?

    **A:** Natural language is ambiguous. Two people can say the
    same thing in many ways. An IR provides:

    1. **Determinism** - One canonical representation
    2. **Queryability** - Every node has an ID
    3. **Precision** - No ambiguity in meaning
    4. **Efficiency** - LLMs generate consistent output
    """
  end

  relations
    rel from="kb.faq" type=contained_by
    rel from="kb.design.four_layers" type=example_of
    rel to="kb.design.philosophy" type=related_to
  end

end

snippet id="kb.faq.why_no_operators" kind="data"

  note "Why no operators?"

  content
    """
    ## Why no operators like + - * /?

    **Q:** Why use `add`, `sub` instead of `+`, `-`?

    **A:** Operators increase grammar complexity and
    introduce parsing ambiguity. Keywords are:

    1. **Unambiguous** - `add` always means addition
    2. **Searchable** - Easy to find all additions
    3. **Token-stable** - LLMs generate consistent sequences
    """
  end

  relations
    rel from="kb.faq" type=contained_by
  end

end

// -----------------------------------------------------------------------------
// Functions for Knowledge Base Management
// -----------------------------------------------------------------------------

snippet id="kb_tools.find_by_topic" kind="fn"

  note "Find all knowledge base entries related to a topic"

  effects
    effect meta
  end

  signature
    fn name="find_by_topic"
      param name="topic" type="String"
      returns collection of="KBEntry"
    end
  end

  body
    // Search content and notes for topic
    step id="s1" kind="query"
      target="project"
      select all
      from="snippets"
      where
        and
          equals field="kind" lit="data"
          or
            contains field="content" var="topic"
            contains field="notes" var="topic"
          end
        end
      end
      as="results"
    end

    step id="s2" kind="return"
      from="results"
      as="_"
    end
  end

end

snippet id="kb_tools.get_ancestors" kind="fn"

  note "Get all ancestors of a node (transitive contained_by)"

  effects
    effect meta
  end

  signature
    fn name="get_ancestors"
      param name="node_id" type="String"
      returns collection of="KBEntry"
    end
  end

  body
    // Traverse contained_by relations transitively
    step id="s1" kind="traverse"
      target="project"
      from="node_id"
      follow type=contained_by
      depth=unbounded
      direction=outgoing
      as="ancestors"
    end

    step id="s2" kind="return"
      from="ancestors"
      as="_"
    end
  end

end

snippet id="kb_tools.get_descendants" kind="fn"

  note "Get all descendants of a node (transitive contains)"

  effects
    effect meta
  end

  signature
    fn name="get_descendants"
      param name="node_id" type="String"
      returns collection of="KBEntry"
    end
  end

  body
    // Traverse contains relations transitively
    step id="s1" kind="traverse"
      target="project"
      from="node_id"
      follow type=contains
      depth=unbounded
      direction=outgoing
      as="descendants"
    end

    step id="s2" kind="return"
      from="descendants"
      as="_"
    end
  end

end

snippet id="kb_tools.find_related" kind="fn"

  note "Find nodes related to a given node (any relation type)"

  effects
    effect meta
  end

  signature
    fn name="find_related"
      param name="node_id" type="String"
      param name="max_depth" type="Int"
      returns collection of="KBEntry"
    end
  end

  body
    // Traverse all relation types in both directions
    step id="s1" kind="traverse"
      target="project"
      from="node_id"
      follow type=related_to
      depth=max_depth
      direction=both
      as="related"
    end

    step id="s2" kind="return"
      from="related"
      as="_"
    end
  end

end

snippet id="kb_tools.find_docs_for_code" kind="fn"

  note "Find all documentation that describes a code snippet"

  effects
    effect meta
  end

  signature
    fn name="find_docs_for_code"
      param name="code_id" type="String"
      returns collection of="KBEntry"
    end
  end

  body
    // Find all data nodes that describe this code
    step id="s1" kind="query"
      target="project"
      select all
      from="snippets"
      where
        and
          equals field="kind" lit="data"
          rel_to target=code_id type=describes
        end
      end
      as="docs"
    end

    step id="s2" kind="return"
      from="docs"
      as="_"
    end
  end

end

snippet id="kb_tools.find_code_for_docs" kind="fn"

  note "Find code that implements what a doc describes"

  effects
    effect meta
  end

  signature
    fn name="find_code_for_docs"
      param name="doc_id" type="String"
      returns collection of="Snippet"
    end
  end

  body
    // Find all code snippets described by this doc
    step id="s1" kind="query"
      target="project"
      select all
      from="snippets"
      where
        and
          not_equals field="kind" lit="data"
          rel_from source=doc_id type=described_by
        end
      end
      as="code"
    end

    step id="s2" kind="return"
      from="code"
      as="_"
    end
  end

end

// -----------------------------------------------------------------------------
// Knowledge Base Update Functions
// -----------------------------------------------------------------------------

snippet id="kb_tools.add_relation" kind="fn"

  note "Add a relation between two knowledge base entries"

  effects
    effect meta
  end

  signature
    fn name="add_relation"
      param name="from_id" type="String"
      param name="to_id" type="String"
      param name="rel_type" type="RelationType"
      returns type="Any"
    end
  end

  body
    // Verify both nodes exist
    step id="s1" kind="query"
      target="project"
      select all
      from="snippets"
      where
        or
          equals field="id" var="from_id"
          equals field="id" var="to_id"
        end
      end
      as="found"
    end

    step id="s2" kind="compute"
      op=equals
      input field="count" of="found"
      input lit=2
      as="both_exist"
    end

    step id="s3" kind="if"
      condition="both_exist"
      then
        // Add relation (compiler auto-maintains inverse)
        step id="s3a" kind="update"
          target="project.snippets"
          set field="relations" op=append from="new_relation"
          where
            equals field="id" var="from_id"
          end
          as="_"
        end
        step id="s3b" kind="return"
          lit="Success"
          as="_"
        end
      end
      else
        step id="s3c" kind="return"
          lit="NotFoundError"
          as="_"
        end
      end
      as="_"
    end
  end

end
