// Higher-Order Functions
// map is pure if the callback is pure, effectful if callback is effectful
//
// Note: The current compiler does not support true higher-order function
// parameters (calling a function passed as an argument). This example
// demonstrates the pattern using extern stubs for the callback dispatch
// mechanism. In a full implementation, `f` and `pred` would be first-class
// function parameters resolved at the call site.

// Extern stubs representing the callback dispatch mechanism.
// These act as placeholders for the higher-order function call pattern.

snippet id="f" kind="extern"
signature
  fn name="f"
    param name="x" type="Any"
    returns type="Any"
  end
end
end

snippet id="pred" kind="extern"
signature
  fn name="pred"
    param name="x" type="Any"
    returns type="Bool"
  end
end
end

snippet id="push" kind="extern"
signature
  fn name="push"
    param name="list" type="List<Any>"
    param name="item" type="Any"
    returns type="Unit"
  end
end
end

snippet id="list.map" kind="fn"

// Effect polymorphism: inherits effects from callback

signature
  fn name="map"
    param name="list" type="Any"
    param name="f" type="Any"
    returns type="Any"
  end
end

body
  step id="s1" kind="bind"
    lit=[]
    mut
    as="result"
  end
  step id="s2" kind="for"
    var="item" in="list"
    step id="s2a" kind="call"
      fn="f"
      arg name="x" from="item"
      as="mapped"
    end
    step id="s2b" kind="call"
      fn="push"
      arg name="list" from="result"
      arg name="item" from="mapped"
      as="_"
    end
    as="_"
  end
  step id="s3" kind="return"
    from="result"
    as="_"
  end
end

end


snippet id="list.filter" kind="fn"

// Predicate should be pure

signature
  fn name="filter"
    param name="list" type="Any"
    param name="pred" type="Any"
    returns type="Any"
  end
end

body
  step id="s1" kind="bind"
    lit=[]
    mut
    as="result"
  end
  step id="s2" kind="for"
    var="item" in="list"
    step id="s2a" kind="call"
      fn="pred"
      arg name="x" from="item"
      as="keep"
    end
    step id="s2b" kind="if"
      condition="keep"
      then
        step id="s2c" kind="call"
          fn="push"
          arg name="list" from="result"
          arg name="item" from="item"
          as="_"
        end
      end
      as="_"
    end
    as="_"
  end
  step id="s3" kind="return"
    from="result"
    as="_"
  end
end

end


snippet id="math.double" kind="fn"

signature
  fn name="double"
    param name="x" type="Int"
    returns type="Int"
  end
end

body
  step id="s1" kind="compute"
    op=mul
    input var="x"
    input lit=2
    as="result"
  end
  step id="s2" kind="return"
    from="result"
    as="_"
  end
end

end


snippet id="math.is_even" kind="fn"

signature
  fn name="is_even"
    param name="x" type="Int"
    returns type="Bool"
  end
end

body
  step id="s1" kind="compute"
    op=mod
    input var="x"
    input lit=2
    as="remainder"
  end
  step id="s2" kind="compute"
    op=equals
    input var="remainder"
    input lit=0
    as="result"
  end
  step id="s3" kind="return"
    from="result"
    as="_"
  end
end

end


snippet id="example.usage" kind="fn"

signature
  fn name="example"
    returns type="Any"
  end
end

body
  step id="s1" kind="bind"
    lit=[1, 2, 3, 4, 5]
    as="nums"
  end
  step id="s2" kind="call"
    fn="list.map"
    arg name="list" from="nums"
    arg name="f" lit="math.double"
    as="doubled"
  end
  step id="s3" kind="call"
    fn="list.filter"
    arg name="list" from="doubled"
    arg name="pred" lit="math.is_even"
    as="evens"
  end
  step id="s4" kind="return"
    from="evens"
    as="_"
  end
end

end
