// RAG Query System
//
// Data Source: Generated by doc-ingestion from docs/guide/
// Build: ./build.sh (concatenates ingested data + this file)
//
// Demonstrates:
// - Keyword search using contains field="content"
// - Relation traversal for neighbor expansion
// - Combined search+expand for LLM context stuffing
// - Hierarchy traversal (ancestors/descendants)
// - Bidirectional code-documentation linking

// =============================================================================
// Query Functions for RAG
// =============================================================================

snippet id="rag.search_by_keyword" kind="fn"

  note "Search documents by keyword in content"

  effects
    effect meta
  end

  signature
    fn name="search_by_keyword"
      param name="keyword" type="String"
      returns type="Any"
    end
  end

  body
    step id="s1" kind="query"
      target="project"
      select all
      from="snippets"
      where
        and
          equals field="kind" lit="data"
          contains field="content" var="keyword"
        end
      end
      as="results"
    end

    step id="s2" kind="return"
      from="results"
      as="_"
    end
  end

end

snippet id="rag.get_all_docs" kind="fn"

  note "Get all documentation nodes"

  effects
    effect meta
  end

  signature
    fn name="get_all_docs"
      returns type="Any"
    end
  end

  body
    step id="s1" kind="query"
      target="project"
      select all
      from="snippets"
      where
        equals field="kind" lit="data"
      end
      as="docs"
    end

    step id="s2" kind="return"
      from="docs"
      as="_"
    end
  end

end

snippet id="rag.get_related" kind="fn"

  note "Get related documents via related_to relation"

  effects
    effect meta
  end

  signature
    fn name="get_related"
      param name="doc_id" type="String"
      returns type="Any"
    end
  end

  body
    // First find the node by id
    step id="s1" kind="query"
      target="project"
      select all
      from="snippets"
      where
        equals field="id" var="doc_id"
      end
      limit=1
      as="source"
    end

    // Then traverse from the found node
    step id="s2" kind="traverse"
      target="project"
      from="source"
      follow type=related_to
      depth=1
      direction=outgoing
      as="related"
    end

    step id="s3" kind="return"
      from="related"
      as="_"
    end
  end

end

snippet id="rag.get_doc_by_id" kind="fn"

  note "Get a specific document by ID"

  effects
    effect meta
  end

  signature
    fn name="get_doc_by_id"
      param name="doc_id" type="String"
      returns type="Any"
    end
  end

  body
    step id="s1" kind="query"
      target="project"
      select all
      from="snippets"
      where
        and
          equals field="kind" lit="data"
          equals field="id" var="doc_id"
        end
      end
      limit=1
      as="doc"
    end

    step id="s2" kind="return"
      from="doc"
      as="_"
    end
  end

end

// =============================================================================
// Hierarchy Traversal Functions (merged from knowledge-base.cov)
// =============================================================================

snippet id="rag.get_ancestors" kind="fn"

  note "Get all ancestors of a node (transitive contained_by)"

  effects
    effect meta
  end

  signature
    fn name="get_ancestors"
      param name="node_id" type="String"
      returns collection of="KBEntry"
    end
  end

  body
    // Traverse contained_by relations transitively
    step id="s1" kind="traverse"
      target="project"
      from="node_id"
      follow type=contained_by
      depth=unbounded
      direction=outgoing
      as="ancestors"
    end

    step id="s2" kind="return"
      from="ancestors"
      as="_"
    end
  end

end

snippet id="rag.get_descendants" kind="fn"

  note "Get all descendants of a node (transitive contains)"

  effects
    effect meta
  end

  signature
    fn name="get_descendants"
      param name="node_id" type="String"
      returns collection of="KBEntry"
    end
  end

  body
    // Traverse contains relations transitively
    step id="s1" kind="traverse"
      target="project"
      from="node_id"
      follow type=contains
      depth=unbounded
      direction=outgoing
      as="descendants"
    end

    step id="s2" kind="return"
      from="descendants"
      as="_"
    end
  end

end

snippet id="rag.find_docs_for_code" kind="fn"

  note "Find all documentation that describes a code snippet"

  effects
    effect meta
  end

  signature
    fn name="find_docs_for_code"
      param name="code_id" type="String"
      returns collection of="KBEntry"
    end
  end

  body
    // Find all data nodes that describe this code
    step id="s1" kind="query"
      target="project"
      select all
      from="snippets"
      where
        and
          equals field="kind" lit="data"
          rel_to target=code_id type=describes
        end
      end
      as="docs"
    end

    step id="s2" kind="return"
      from="docs"
      as="_"
    end
  end

end

snippet id="rag.find_code_for_docs" kind="fn"

  note "Find code that implements what a doc describes"

  effects
    effect meta
  end

  signature
    fn name="find_code_for_docs"
      param name="doc_id" type="String"
      returns collection of="Snippet"
    end
  end

  body
    // Find all code snippets described by this doc
    step id="s1" kind="query"
      target="project"
      select all
      from="snippets"
      where
        and
          not_equals field="kind" lit="data"
          rel_from source=doc_id type=described_by
        end
      end
      as="code"
    end

    step id="s2" kind="return"
      from="code"
      as="_"
    end
  end

end

snippet id="rag.add_relation" kind="fn"

  note "Add a relation between two knowledge base entries"

  effects
    effect meta
  end

  signature
    fn name="add_relation"
      param name="from_id" type="String"
      param name="to_id" type="String"
      param name="rel_type" type="RelationType"
      returns type="Any"
    end
  end

  body
    // Verify both nodes exist
    step id="s1" kind="query"
      target="project"
      select all
      from="snippets"
      where
        or
          equals field="id" var="from_id"
          equals field="id" var="to_id"
        end
      end
      as="found"
    end

    step id="s2" kind="compute"
      op=equals
      input field="count" of="found"
      input lit=2
      as="both_exist"
    end

    step id="s3" kind="if"
      condition="both_exist"
      then
        // Add relation (compiler auto-maintains inverse)
        step id="s3a" kind="update"
          target="project.snippets"
          set field="relations" op=append from="new_relation"
          where
            equals field="id" var="from_id"
          end
          as="_"
        end
        step id="s3b" kind="return"
          lit="Success"
          as="_"
        end
      end
      else
        step id="s3c" kind="return"
          lit="NotFoundError"
          as="_"
        end
      end
      as="_"
    end
  end

end
