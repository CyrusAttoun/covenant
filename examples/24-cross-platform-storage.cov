// Cross-Platform Storage Example
//
// Demonstrates std.storage.kv and std.storage.doc modules.
// This code works identically on browser, Node.js, and WASI.

// ============================================================
// Extern stubs for std.storage and JSON functions
// ============================================================

snippet id="std.storage.kv.set" kind="extern"
effects
  effect std.storage
end
signature
  fn name="set"
    param name="key" type="String"
    param name="value" type="String"
    returns type="Unit"
  end
end
end

snippet id="std.storage.kv.get" kind="extern"
effects
  effect std.storage
end
signature
  fn name="get"
    param name="key" type="String"
    returns type="Any"
  end
end
end

snippet id="std.storage.kv.list" kind="extern"
effects
  effect std.storage
end
signature
  fn name="list"
    param name="prefix" type="String"
    returns type="Any"
  end
end
end

snippet id="std.storage.kv.delete" kind="extern"
effects
  effect std.storage
end
signature
  fn name="delete"
    param name="key" type="String"
    returns type="Unit"
  end
end
end

snippet id="std.storage.doc.put" kind="extern"
effects
  effect std.storage
end
signature
  fn name="put"
    param name="collection" type="String"
    param name="id" type="String"
    param name="data" type="Any"
    returns type="Any"
  end
end
end

snippet id="std.storage.doc.get" kind="extern"
effects
  effect std.storage
end
signature
  fn name="get"
    param name="collection" type="String"
    param name="id" type="String"
    returns type="Any"
  end
end
end

snippet id="std.storage.doc.query" kind="extern"
effects
  effect std.storage
end
signature
  fn name="query"
    param name="collection" type="String"
    param name="filter" type="Any"
    param name="order_by" type="String"
    param name="order_dir" type="String"
    param name="limit" type="Any"
    returns type="Any"
  end
end
end

snippet id="std.storage.doc.create_index" kind="extern"
effects
  effect std.storage
end
signature
  fn name="create_index"
    param name="collection" type="String"
    param name="field" type="String"
    returns type="Unit"
  end
end
end

snippet id="json.parse" kind="extern"
signature
  fn name="parse"
    param name="text" type="String"
    returns type="Any"
  end
end
end

snippet id="json.stringify" kind="extern"
signature
  fn name="stringify"
    param name="value" type="Any"
    returns type="String"
  end
end
end

// ============================================================
// Example 1: Key-Value Storage
// ============================================================

// Save and retrieve user preferences
snippet id="example.kv.save_preference" kind="fn"

effects
  effect std.storage
end

signature
  fn name="save_preference"
    param name="user_id" type="String"
    param name="key" type="String"
    param name="value" type="String"
    returns type="Unit"
  end
end

body
  // Build namespaced key: "prefs:{user_id}:{key}"
  step id="s1a" kind="call"
    fn="text.concat"
    arg name="a" lit="prefs:"
    arg name="b" from="user_id"
    as="key_part1"
  end
  step id="s1b" kind="call"
    fn="text.concat"
    arg name="a" from="key_part1"
    arg name="b" lit=":"
    as="key_part2"
  end
  step id="s1" kind="call"
    fn="text.concat"
    arg name="a" from="key_part2"
    arg name="b" from="key"
    as="storage_key"
  end

  step id="s2" kind="call"
    fn="std.storage.kv.set"
    arg name="key" from="storage_key"
    arg name="value" from="value"
    as="_"
  end
end

end

// Get a user preference
snippet id="example.kv.get_preference" kind="fn"

effects
  effect std.storage
end

signature
  fn name="get_preference"
    param name="user_id" type="String"
    param name="key" type="String"
    param name="default" type="String"
    returns type="Any"
  end
end

body
  step id="s1a" kind="call"
    fn="text.concat"
    arg name="a" lit="prefs:"
    arg name="b" from="user_id"
    as="key_part1"
  end
  step id="s1b" kind="call"
    fn="text.concat"
    arg name="a" from="key_part1"
    arg name="b" lit=":"
    as="key_part2"
  end
  step id="s1" kind="call"
    fn="text.concat"
    arg name="a" from="key_part2"
    arg name="b" from="key"
    as="storage_key"
  end

  step id="s2" kind="call"
    fn="std.storage.kv.get"
    arg name="key" from="storage_key"
    as="maybe_value"
  end

  // Return value or default
  step id="s3" kind="return"
    from="maybe_value"
    as="_"
  end
end

end

// List all preferences for a user
snippet id="example.kv.list_preferences" kind="fn"

effects
  effect std.storage
end

signature
  fn name="list_user_prefs"
    param name="user_id" type="String"
    returns type="String[]"
  end
end

body
  step id="s1a" kind="call"
    fn="text.concat"
    arg name="a" lit="prefs:"
    arg name="b" from="user_id"
    as="prefix_part1"
  end
  step id="s1" kind="call"
    fn="text.concat"
    arg name="a" from="prefix_part1"
    arg name="b" lit=":"
    as="prefix"
  end

  step id="s2" kind="call"
    fn="std.storage.kv.list"
    arg name="prefix" from="prefix"
    as="keys"
  end

  step id="s3" kind="return"
    from="keys"
    as="_"
  end
end

end

// ============================================================
// Example 2: Document Storage with Function API
// ============================================================

// Create or update a user document
snippet id="example.doc.save_user" kind="fn"

effects
  effect std.storage
end

signature
  fn name="save_user"
    param name="id" type="String"
    param name="name" type="String"
    param name="email" type="String"
    param name="role" type="String"
    returns type="Document"
  end
end

body
  // Build user data as a struct
  step id="s1" kind="construct"
    type="UserData"
    field name="name" from="name"
    field name="email" from="email"
    field name="role" from="role"
    field name="status" lit="active"
    as="user_data"
  end

  step id="s2" kind="call"
    fn="std.storage.doc.put"
    arg name="collection" lit="users"
    arg name="id" from="id"
    arg name="data" from="user_data"
    as="doc"
  end

  step id="s3" kind="return"
    from="doc"
    as="_"
  end
end

end

// Find active admins using JSON filter API
snippet id="example.doc.find_admins" kind="fn"

effects
  effect std.storage
end

signature
  fn name="find_active_admins"
    returns type="Document[]"
  end
end

body
  step id="s1" kind="call"
    fn="std.storage.doc.query"
    arg name="collection" lit="users"
    arg name="filter" lit="{\"$and\": [{\"status\": \"active\"}, {\"role\": \"admin\"}]}"
    arg name="order_by" lit="name"
    arg name="order_dir" lit="asc"
    arg name="limit" lit=100
    as="result"
  end

  step id="s2" kind="call"
    fn="map.get"
    arg name="map" from="result"
    arg name="key" lit="documents"
    as="docs"
  end

  step id="s3" kind="return"
    from="docs"
    as="_"
  end
end

end

// ============================================================
// Example 3: Document Storage with Query Dialect
// ============================================================

// Find users by status and age using indexeddb dialect
snippet id="example.doc.find_by_criteria" kind="fn"

effects
  effect std.storage
end

signature
  fn name="find_eligible_users"
    param name="min_age" type="Int"
    returns type="Any"
  end
end

body
  // Cross-platform query targeting std.storage
  step id="s1" kind="query"
    target="std.storage"
    select all
    from="users"
    where
      and
        equals field="status" lit="active"
        greater field="age" var="min_age"
      end
    end
    order by="created_at" dir="desc"
    limit=50
    as="users"
  end

  step id="s2" kind="return"
    from="users"
    as="_"
  end
end

end

// Count pending orders
snippet id="example.doc.count_pending" kind="fn"

effects
  effect std.storage
end

signature
  fn name="count_pending_orders"
    returns type="Int"
  end
end

body
  step id="s1" kind="query"
    target="std.storage"
    select all
    from="orders"
    where
      or
        equals field="status" lit="pending"
        equals field="status" lit="processing"
      end
    end
    as="pending_orders"
  end

  step id="s2" kind="call"
    fn="list.len"
    arg name="list" from="pending_orders"
    as="count"
  end

  step id="s3" kind="return"
    from="count"
    as="_"
  end
end

end

// ============================================================
// Example 4: Setup Indexes
// ============================================================

// Initialize storage with indexes for efficient queries
snippet id="example.doc.setup_indexes" kind="fn"

effects
  effect std.storage
end

signature
  fn name="setup_storage"
    returns type="Any"
  end
end

body
  // Create indexes on frequently queried fields
  step id="s1" kind="call"
    fn="std.storage.doc.create_index"
    arg name="collection" lit="users"
    arg name="field" lit="status"
    as="_"
  end

  step id="s2" kind="call"
    fn="std.storage.doc.create_index"
    arg name="collection" lit="users"
    arg name="field" lit="role"
    as="_"
  end

  step id="s3" kind="call"
    fn="std.storage.doc.create_index"
    arg name="collection" lit="orders"
    arg name="field" lit="status"
    as="_"
  end

  step id="s4" kind="call"
    fn="std.storage.doc.create_index"
    arg name="collection" lit="orders"
    arg name="field" lit="created_at"
    as="_"
  end

  step id="s5" kind="return"
    lit=none
    as="_"
  end
end

end

// ============================================================
// Example 5: Combined KV and Doc Usage
// ============================================================

// Cache frequently accessed user data
snippet id="example.combined.get_user_cached" kind="fn"

effects
  effect std.storage
end

signature
  fn name="get_user_cached"
    param name="user_id" type="String"
    returns type="Any"
  end
end

body
  // Build cache key
  step id="s1" kind="call"
    fn="text.concat"
    arg name="a" lit="cache:user:"
    arg name="b" from="user_id"
    as="cache_key"
  end

  // Check cache first
  step id="s2" kind="call"
    fn="std.storage.kv.get"
    arg name="key" from="cache_key"
    as="cached"
  end

  // Try to parse cached value, or fetch from doc store and cache it
  step id="s3" kind="call"
    fn="json.parse"
    arg name="text" from="cached"
    as="parsed"
  end

  // Fetch from document store (fallback)
  step id="s4" kind="call"
    fn="std.storage.doc.get"
    arg name="collection" lit="users"
    arg name="id" from="user_id"
    as="doc"
  end

  // Extract data from document
  step id="s5" kind="call"
    fn="map.get"
    arg name="map" from="doc"
    arg name="key" lit="data"
    as="user_data"
  end

  // Cache the result for future use
  step id="s6" kind="call"
    fn="json.stringify"
    arg name="value" from="user_data"
    as="json_str"
  end

  step id="s7" kind="call"
    fn="std.storage.kv.set"
    arg name="key" from="cache_key"
    arg name="value" from="json_str"
    as="_"
  end

  step id="s8" kind="return"
    from="user_data"
    as="_"
  end
end

end
