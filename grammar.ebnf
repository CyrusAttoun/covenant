(* Covenant Grammar - Machine-First IR *)
(* Optimized for LLM generation: deterministic, tree-shaped, keyword-heavy *)
(* Every construct has an ID, canonical ordering, no operators *)

(* === Design Principles === *)
(*
   1. Everything is a block with kind, id, and explicit end
   2. No operators - use keywords: add, equals, and, or, not
   3. No expression nesting - one operation per step, named outputs (SSA)
   4. Strict canonical ordering - one valid way to write everything
   5. ~40-50 keywords total - small grammar surface area
   6. Double quotes only, // comments
*)

(* === Top Level === *)
program        = { snippet } ;

snippet        = "snippet" snippet_header { section } "end" ;
snippet_header = "id" "=" STRING "kind" "=" snippet_kind ;
snippet_kind   = "fn" | "struct" | "enum" | "module" | "database" | "extern" | "test" ;

(* === Sections (in canonical order) === *)
section        = effects_section
               | requires_section
               | types_section
               | tools_section
               | signature_section
               | body_section
               | tests_section
               | metadata_section ;

(* === Effects Section === *)
(* Declares capabilities this snippet requires *)
effects_section = "effects" { effect_decl } "end" ;
effect_decl     = "effect" IDENT [ effect_params ] ;
effect_params   = "(" { effect_param } ")" ;
effect_param    = IDENT "=" value ;

(* === Requirements Section === *)
(* First-class specifications, queryable and linkable to tests *)
requires_section = "requires" { requirement } "end" ;
requirement      = "req" "id" "=" STRING { req_field } "end" ;
req_field        = "text" STRING
                 | "priority" ( "critical" | "high" | "medium" | "low" )
                 | "status" ( "draft" | "approved" | "implemented" | "tested" ) ;

(* === Types Section === *)
(* Type definitions local to this snippet *)
types_section  = "types" { type_def } "end" ;
type_def       = struct_def | enum_def | alias_def ;

struct_def     = "struct" "name" "=" STRING { struct_field } "end" ;
struct_field   = "field" "name" "=" STRING "type" "=" type_ref [ field_attrs ] ;
field_attrs    = { "optional" | "default" "=" value } ;

enum_def       = "enum" "name" "=" STRING { enum_variant } "end" ;
enum_variant   = "variant" "name" "=" STRING [ variant_data ] ;
variant_data   = "(" type_list ")" | "{" { struct_field } "}" ;

alias_def      = "alias" "name" "=" STRING "type" "=" type_ref ;

(* === Tools Section === *)
(* References to external tool contracts *)
tools_section  = "tools" { tool_ref } "end" ;
tool_ref       = "tool" "id" "=" STRING "contract" "=" STRING [ tool_attrs ] "end" ;
tool_attrs     = { "idempotent" "=" IDENT
                 | "timeout" "=" duration
                 | "retry" "=" retry_spec
                 | "auth" "=" STRING } ;
retry_spec     = "(" "max" "=" NUMBER "backoff" "=" ( "none" | "linear" | "exponential" ) ")" ;
duration       = NUMBER ( "ms" | "s" | "m" ) ;

(* === Signature Section === *)
(* Function, struct, or enum public interface *)
signature_section = "signature" signature_body "end" ;

signature_body = fn_signature | struct_signature | enum_signature ;

fn_signature   = "fn" "name" "=" STRING { fn_sig_part } "end" ;
fn_sig_part    = param_decl | returns_decl | generic_decl ;

param_decl     = "param" "name" "=" STRING "type" "=" type_ref [ param_attrs ] ;
param_attrs    = { "optional" | "default" "=" value } ;

returns_decl   = "returns" return_type "end" ;
return_type    = "type" "=" type_ref [ "optional" ]
               | "union" { union_member } ;
union_member   = "type" "=" type_ref [ "optional" ] ;

generic_decl   = "generic" "name" "=" STRING [ "constraint" "=" type_ref ] ;

struct_signature = "struct" "name" "=" STRING { struct_field } "end" ;
enum_signature   = "enum" "name" "=" STRING { enum_variant } "end" ;

(* === Body Section === *)
(* Implementation as a sequence of steps (SSA form) *)
body_section   = "body" { step } "end" ;

step           = "step" "id" "=" STRING "kind" "=" step_kind step_body "as" "=" STRING "end" ;
step_kind      = "compute" | "call" | "query" | "bind" | "return"
               | "if" | "match" | "for" | "insert" | "update" | "delete" ;

step_body      = compute_body | call_body | query_body | bind_body | return_body
               | if_body | match_body | for_body
               | insert_body | update_body | delete_body ;

(* --- Compute: arithmetic and logic --- *)
compute_body   = "op" "=" binary_op input input
               | "op" "=" unary_op input ;

binary_op      = "add" | "sub" | "mul" | "div" | "mod"
               | "equals" | "not_equals" | "less" | "greater" | "less_eq" | "greater_eq"
               | "and" | "or"
               | "concat" | "contains" ;

unary_op       = "not" | "neg" ;

input          = "input" input_source ;
input_source   = "var" "=" STRING
               | "lit" "=" literal
               | "field" "=" STRING "of" "=" STRING ;

(* --- Call: function or tool invocation --- *)
call_body      = ( "fn" "=" STRING | "tool" "=" STRING ) { call_arg } [ error_handler ] ;
call_arg       = "arg" "name" "=" STRING "from" "=" STRING ;
error_handler  = "handle" { handle_case } "end" ;
handle_case    = "case" "type" "=" type_ref { step } "end" ;

(* --- Query: database or AST traversal --- *)
query_body     = "target" "=" STRING query_clauses ;
query_clauses  = select_clause [ from_clause ] [ join_clause ] [ where_clause ]
                 [ order_clause ] [ limit_clause ] ;

select_clause  = "select" ( "all" | { select_item } ) ;
select_item    = "field" "=" STRING [ "alias" "=" STRING ] ;

from_clause    = "from" "=" STRING [ "alias" "=" STRING ] ;

join_clause    = { "join" "type" "=" join_type "table" "=" STRING "on" condition "end" } ;
join_type      = "inner" | "left" | "right" | "outer" ;

where_clause   = "where" condition "end" ;

condition      = simple_condition | compound_condition ;
simple_condition = compare_op "field" "=" STRING ( "var" "=" STRING | "lit" "=" literal ) ;
compare_op     = "equals" | "not_equals" | "less" | "greater" | "less_eq" | "greater_eq"
               | "contains" | "matches" ;
compound_condition = ( "and" | "or" ) { condition } "end"
                   | "not" condition ;

order_clause   = "order" { order_item } ;
order_item     = "by" "=" STRING "dir" "=" ( "asc" | "desc" ) ;

limit_clause   = "limit" "=" NUMBER [ "offset" "=" NUMBER ] ;

(* --- Bind: variable binding --- *)
bind_body      = [ "mut" ] "from" "=" STRING ;

(* --- Return --- *)
return_body    = [ "from" "=" STRING ] ;

(* --- If --- *)
if_body        = "condition" "=" STRING "then" { step } [ "else" { step } ] ;

(* --- Match --- *)
match_body     = "on" "=" STRING { match_case } ;
match_case     = "case" pattern { step } "end" ;

pattern        = "wildcard"
               | "binding" "=" STRING
               | "literal" "=" literal
               | "variant" "type" "=" STRING [ "bindings" "=" "(" { STRING } ")" ]
               | "struct" "type" "=" STRING [ "fields" "=" "(" { STRING } ")" ] ;

(* --- For --- *)
for_body       = "var" "=" STRING "in" "=" STRING { step } ;

(* --- Insert --- *)
insert_body    = "into" "=" STRING { field_value } ;
field_value    = "set" "field" "=" STRING "from" "=" STRING ;

(* --- Update --- *)
update_body    = "target" "=" STRING { field_value } [ where_clause ] ;

(* --- Delete --- *)
delete_body    = "from" "=" STRING [ where_clause ] ;

(* === Tests Section === *)
(* Test definitions linked to requirements *)
tests_section  = "tests" { test_def } "end" ;
test_def       = "test" "id" "=" STRING test_attrs { step } "end" ;
test_attrs     = { "kind" "=" test_kind
                 | "covers" "=" STRING
                 | "property" "=" STRING } ;
test_kind      = "unit" | "property" | "integration" | "golden" ;

(* === Metadata Section === *)
(* Additional metadata for AI planning *)
metadata_section = "metadata" { meta_field } "end" ;
meta_field     = "author" "=" STRING
               | "created" "=" STRING
               | "modified" "=" STRING
               | "confidence" "=" NUMBER
               | "provenance" "=" STRING
               | "cost_hint" "=" ( "cheap" | "moderate" | "expensive" )
               | "latency_hint" "=" ( "fast" | "medium" | "slow" ) ;

(* === Type References === *)
type_ref       = type_path [ type_modifiers ] ;
type_path      = IDENT { "::" IDENT } ;
type_modifiers = { "?" | "[]" | "<" type_list ">" } ;
type_list      = type_ref { "," type_ref } ;

(* === Values and Literals === *)
value          = literal | "var" "=" STRING ;
literal        = NUMBER [ ":" type_ref ]
               | STRING
               | "true" | "false"
               | "none"
               | array_literal
               | struct_literal ;

array_literal  = "[" [ literal { "," literal } ] "]" ;
struct_literal = "{" [ struct_field_lit { "," struct_field_lit } ] "}" ;
struct_field_lit = STRING ":" literal ;

(* === Tokens === *)
IDENT          = letter { letter | digit | "_" } ;
NUMBER         = digit { digit } [ "." digit { digit } ] ;
STRING         = '"' { any_char_except_quote | escape_seq } '"' ;
escape_seq     = "\\" ( '"' | "\\" | "n" | "t" | "r" ) ;

(* === Comments === *)
(* // single line comment *)
COMMENT        = "//" { any_char_except_newline } NEWLINE ;

(* === Reserved Keywords (canonical list) === *)
(*
   Blocks: snippet, end, effects, requires, types, tools, signature, body, tests, metadata
   Types: struct, enum, alias, field, variant, fn, param, returns, union, generic, type
   Effects: effect
   Requirements: req, text, priority, status
   Tools: tool, contract, idempotent, timeout, retry, auth
   Steps: step, kind, as, op, input, var, lit, from, of
   Operators: add, sub, mul, div, mod, equals, not_equals, less, greater, less_eq, greater_eq, and, or, not, neg, concat, contains, matches
   Control: if, then, else, match, case, for, in, return, bind, mut
   Query: query, target, select, all, from, join, inner, left, right, outer, on, where, order, by, dir, asc, desc, limit, offset
   CRUD: insert, into, update, set, delete
   Tests: test, covers, property, unit, integration, golden
   Metadata: author, created, modified, confidence, provenance, cost_hint, latency_hint, cheap, moderate, expensive, fast, medium, slow
   Literals: true, false, none
   Modifiers: optional, default, constraint, handle, wildcard, binding, literal
*)
