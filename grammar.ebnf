(* Covenant Grammar - EBNF *)
(* This is the canonical, machine-parseable grammar definition *)
(* Examples in /examples/*.cov should validate against this *)

(* === Top Level === *)
program        = { top_level } ;
top_level      = module_import | declaration ;
declaration    = module_decl | type_decl | fn_decl | extern_decl | database_decl ;

(* === Module Imports === *)
(* Module-level imports bring functions into scope for all functions in the file *)
(* They also inherit the effects of the imported functions *)
module_import  = "import" "{" ident_list "}" "from" IDENT ;

(* === Modules === *)
module_decl    = "module" IDENT "{" { declaration } "}" ;

(* === Types === *)
type_decl      = struct_decl | enum_decl | alias_decl ;

struct_decl    = "struct" IDENT [ generic_params ] "{"
                   { field_decl }
                 "}" ;

enum_decl      = "enum" IDENT [ generic_params ] "{"
                   { variant_decl }
                 "}" ;

alias_decl     = "type" IDENT [ generic_params ] "=" type ;

field_decl     = IDENT ":" type [ "=" expr ] ;
variant_decl   = IDENT [ "(" type_list ")" | "{" { field_decl } "}" ] ;

type           = union_type ;
union_type     = base_type { "|" base_type } ;  (* union: User | Error *)
base_type      = primary_type { type_suffix } ;
type_suffix    = "?"                            (* optional *)
               | "[" "]" ;                      (* list *)
primary_type   = path
               | "(" type_list ")"              (* tuple *)
               | "(" type_list ")" "->" type    (* function type *)
               | struct_type ;                  (* anonymous struct type *)
struct_type    = "{" [ field_type_list ] "}" ;
field_type_list = field_type { "," field_type } ;
field_type     = IDENT ":" type ;

generic_params = "<" ident_list ">" ;
path           = IDENT { "::" IDENT } ;

(* === Functions === *)
(* No fn keyword - signature shape identifies functions *)
(* Imports come after signature, before body - they declare effects *)
fn_decl        = IDENT [ generic_params ]
                 "(" [ param_list ] ")"
                 [ "->" type ]
                 { import_clause }
                 [ ensures_clause ]
                 block ;

import_clause  = "import" "{" ident_list "}" "from" IDENT ;
ensures_clause = "ensures" ":" expr ;           (* postconditions *)

(* === AST Metadata (Compiler-Computed, Not In Source) === *)
(* These are computed by the compiler and stored in the AST/symbol graph *)
(* Queryable via the project query interface *)
(*
ast_metadata   = {
    // Bidirectional call graph
    called_by: [symbol_id],      // functions that call this function
    calls: [symbol_id],          // functions this function calls

    // Bidirectional reference graph
    references: [symbol_id],     // types/symbols this function references
    referenced_by: [symbol_id],  // what references this type/symbol

    // Effect tracking
    effects: [effect_id],        // computed effect set (transitive)

    // Statistical metadata (from tests/runtime, when available)
    return_distribution: {       // observed return type frequencies
        type: probability,       // e.g., { User: 0.99, NotFound: 0.01 }
    },
}
*)

param_list     = param { "," param } ;
param          = IDENT ":" type ;

(* === Extern Declarations (FFI Bindings) === *)
(* Declares external functions provided by host runtime *)
(* Maps npm/JS libraries to Covenant's type and effect system *)
extern_decl    = "extern" IDENT "(" [ param_list ] ")" "->" type
                 "from" STRING
                 "effect" "[" ident_list "]" ;

(* === Database Declarations === *)
(* Typed database bindings - queries compile to SQL *)
(* Schema is declared in Covenant, validated against actual database *)
database_decl  = "database" IDENT
                 [ "connection" ":" STRING ]
                 "{" { table_decl } "}" ;

table_decl     = "table" IDENT "{"
                   { column_decl }
                   { constraint_decl }
                 "}" ;

column_decl    = IDENT ":" column_type [ column_attrs ] ;
column_type    = "Int" | "String" | "Bool" | "Float" | "DateTime" | "Bytes"
               | IDENT ;                        (* foreign key reference *)
column_attrs   = { "primary" | "unique" | "nullable" | "auto" } ;

constraint_decl = "unique" "(" ident_list ")"
                | "index" "(" ident_list ")"
                | "foreign" IDENT "->" path ;

(* === Query Expressions === *)
(* Unified query syntax for all data sources *)
(* The import type determines how the query compiles: *)
(*   - database import → SQL *)
(*   - meta import → AST traversal *)
(*   - module path → scoped AST query *)
query_expr     = "query" path "{" query_body "}" ;

query_body     = select_clause
                 [ from_clause ]
                 [ join_clause ]
                 [ where_clause ]
                 [ order_clause ]
                 [ limit_clause ] ;

select_clause  = "select" select_items ;
select_items   = "*" | select_item { "," select_item } ;
select_item    = expr [ "as" IDENT ] ;

from_clause    = "from" IDENT [ "as" IDENT ] ;
join_clause    = { join_type "join" IDENT "on" expr } ;
join_type      = "inner" | "left" | "right" | "outer" ;

where_clause   = "where" expr ;
order_clause   = "order" "by" order_item { "," order_item } ;
order_item     = expr [ "asc" | "desc" ] ;
limit_clause   = "limit" expr [ "offset" expr ] ;

(* === Mutation Expressions === *)
(* For database: compile to INSERT/UPDATE/DELETE *)
(* For project (AST): metaprogramming operations *)
insert_expr    = "insert" "into" path struct_expr ;
update_expr    = "update" path "set" field_init_list [ where_clause ] ;
delete_expr    = "delete" "from" path [ where_clause ] ;

(* === Statements === *)
block          = "{" { statement } "}" ;

statement      = let_stmt
               | return_stmt
               | if_stmt
               | match_stmt
               | for_stmt
               | expr_stmt ;

(* let uses = for initial binding, := for reassignment *)
let_stmt       = "let" [ "mut" ] IDENT [ ":" type ] "=" expr ;
return_stmt    = "return" [ expr ] ;
expr_stmt      = expr ;

if_stmt        = "if" expr block [ "else" ( if_stmt | block ) ] ;

match_stmt     = "match" expr "{" { match_arm } "}" ;
match_arm      = pattern "=>" ( expr | block ) "," ;

for_stmt       = "for" IDENT "in" expr block ;

(* === Expressions === *)
(* Note: = is equality (not ==), := is assignment *)
(* This aligns with SQL and avoids the = vs == confusion *)
(*
   Null handling:
   - 'none' represents absence of value (like Option::None)
   - In queries: x = none compiles to SQL "x IS NULL"
   - In queries: x != none compiles to SQL "x IS NOT NULL"
   - Nullable columns become optional types (T?)
*)
expr           = assignment ;
assignment     = IDENT ":=" expr | logical_or ;
logical_or     = logical_and { "||" logical_and } ;
logical_and    = equality { "&&" equality } ;
equality       = comparison { ( "=" | "!=" ) comparison } ;
comparison     = term { ( "<" | ">" | "<=" | ">=" ) term } ;
term           = factor { ( "+" | "-" ) factor } ;
factor         = unary { ( "*" | "/" | "%" ) unary } ;
unary          = ( "!" | "-" ) unary | postfix ;
postfix        = primary { call | index | field_access | handle_expr } ;

call           = "(" [ expr_list ] ")" ;
index          = "[" expr "]" ;
field_access   = "." IDENT ;
handle_expr    = "handle" "{" { match_arm } "}" ;  (* catch errors locally *)

primary        = IDENT
               | literal
               | "(" expr ")"
               | block_expr
               | array_expr
               | struct_expr
               | closure
               | query_expr
               | insert_expr
               | update_expr
               | delete_expr ;

struct_expr    = [ path ] "{" [ field_init_list ] "}" ;
field_init_list = field_init { "," field_init } ;
field_init     = IDENT ":" expr
               | IDENT ;                        (* shorthand: { name } same as { name: name } *)

block_expr     = block ;                        (* blocks are expressions *)
array_expr     = "[" [ expr_list ] "]" ;
closure        = "|" [ param_list ] "|" ( expr | block ) ;

literal        = NUMBER | STRING | "true" | "false" | "none" ;

(* === Patterns (for match) === *)
pattern        = "_"
               | IDENT
               | literal
               | path "(" [ pattern_list ] ")"
               | path "{" [ field_pattern_list ] "}" ;

(* === Lists === *)
ident_list     = IDENT { "," IDENT } ;
type_list      = type { "," type } ;
expr_list      = expr { "," expr } ;
pattern_list   = pattern { "," pattern } ;

(* === Tokens === *)
IDENT          = letter { letter | digit | "_" } ;
NUMBER         = digit { digit } [ "." digit { digit } ] ;
STRING         = '"' { any_char } '"' ;
