// JSON Module Test Suite
// Comprehensive unit tests for JSON parsing, serialization, and manipulation.
// Tests cover: json.parse, json.stringify, json.format, json.is_valid, type guards, field access
// Test naming: T-JSON-XXX | Requirements: R-JSON-XXX

// ============================================================
// Requirements Definition
// ============================================================

snippet id="json_requirements" kind="data"

requires
  // Parsing
  req id="R-JSON-001"
    text "parse() correctly parses valid JSON primitives (null, bool, number, string)"
    priority critical
  end

  req id="R-JSON-002"
    text "parse() correctly parses JSON arrays"
    priority critical
  end

  req id="R-JSON-003"
    text "parse() correctly parses JSON objects"
    priority critical
  end

  req id="R-JSON-004"
    text "parse() returns JsonError::ParseError for invalid JSON"
    priority critical
  end

  req id="R-JSON-005"
    text "parse() handles nested structures correctly"
    priority high
  end

  // Serialization
  req id="R-JSON-006"
    text "stringify() serializes JSON primitives correctly"
    priority critical
  end

  req id="R-JSON-007"
    text "stringify() serializes arrays and objects correctly"
    priority critical
  end

  req id="R-JSON-008"
    text "format() produces pretty-printed JSON with indentation"
    priority high
  end

  // Validation
  req id="R-JSON-009"
    text "is_valid() returns true for valid JSON strings"
    priority high
  end

  req id="R-JSON-010"
    text "is_valid() returns false for invalid JSON strings"
    priority high
  end

  // Type Guards
  req id="R-JSON-011"
    text "Type guard functions (is_object, is_array, etc.) correctly identify types"
    priority high
  end

  // Field Access
  req id="R-JSON-012"
    text "get_field() extracts fields from JSON objects"
    priority high
  end

  req id="R-JSON-013"
    text "get_index() extracts elements from JSON arrays"
    priority high
  end

  // Extraction
  req id="R-JSON-014"
    text "as_string(), as_number(), as_bool() extract typed values correctly"
    priority high
  end

  // Edge Cases
  req id="R-JSON-015"
    text "parse() handles escaped characters correctly"
    priority high
  end

  req id="R-JSON-016"
    text "parse() handles empty arrays and objects"
    priority medium
  end

  req id="R-JSON-017"
    text "Round-trip: stringify(parse(x)) preserves data"
    priority high
  end
end

end

// ============================================================
// Test Suite
// ============================================================

snippet id="json_tests" kind="test"

tests
  // ============================================================
  // Parse Tests - Primitives
  // ============================================================

  test id="T-JSON-001" kind="unit" covers="R-JSON-001"
    // parse() correctly parses null
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="null"
      as="result"
    end

    step id="s2" kind="call"
      fn="json.is_null"
      arg name="value" from="result"
      as="is_null"
    end

    step id="s3" kind="call"
      fn="testing_assert_true"
      arg name="condition" from="is_null"
      arg name="message" lit="Parsed value should be null"
      as="_"
    end
  end

  test id="T-JSON-002" kind="unit" covers="R-JSON-001"
    // parse() correctly parses booleans
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="true"
      as="result"
    end

    step id="s2" kind="call"
      fn="json.as_bool"
      arg name="value" from="result"
      as="bool_val"
    end

    step id="s3" kind="call"
      fn="testing_assert_equals"
      arg name="actual" from="bool_val"
      arg name="expected" lit=true
      arg name="message" lit="Parsed boolean should be true"
      as="_"
    end
  end

  test id="T-JSON-003" kind="unit" covers="R-JSON-001"
    // parse() correctly parses numbers
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="42.5"
      as="result"
    end

    step id="s2" kind="call"
      fn="json.as_number"
      arg name="value" from="result"
      as="num_val"
    end

    step id="s3" kind="call"
      fn="testing_assert_equals"
      arg name="actual" from="num_val"
      arg name="expected" lit=42.5
      arg name="message" lit="Parsed number should be 42.5"
      as="_"
    end
  end

  test id="T-JSON-004" kind="unit" covers="R-JSON-001"
    // parse() correctly parses strings
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="\"hello world\""
      as="result"
    end

    step id="s2" kind="call"
      fn="json.as_string"
      arg name="value" from="result"
      as="str_val"
    end

    step id="s3" kind="call"
      fn="testing_assert_equals"
      arg name="actual" from="str_val"
      arg name="expected" lit="hello world"
      arg name="message" lit="Parsed string should be 'hello world'"
      as="_"
    end
  end

  // ============================================================
  // Parse Tests - Arrays and Objects
  // ============================================================

  test id="T-JSON-005" kind="unit" covers="R-JSON-002"
    // parse() correctly parses JSON arrays
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="[1, 2, 3]"
      as="result"
    end

    step id="s2" kind="call"
      fn="json.is_array"
      arg name="value" from="result"
      as="is_arr"
    end

    step id="s3" kind="call"
      fn="testing_assert_true"
      arg name="condition" from="is_arr"
      arg name="message" lit="Parsed value should be an array"
      as="_"
    end
  end

  test id="T-JSON-006" kind="unit" covers="R-JSON-003"
    // parse() correctly parses JSON objects
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="{\"name\":\"Alice\",\"age\":30}"
      as="result"
    end

    step id="s2" kind="call"
      fn="json.is_object"
      arg name="value" from="result"
      as="is_obj"
    end

    step id="s3" kind="call"
      fn="testing_assert_true"
      arg name="condition" from="is_obj"
      arg name="message" lit="Parsed value should be an object"
      as="_"
    end

    // Test field extraction
    step id="s4" kind="call"
      fn="json.get_field"
      arg name="obj" from="result"
      arg name="key" lit="name"
      as="name_field"
    end

    step id="s5" kind="call"
      fn="json.as_string"
      arg name="value" from="name_field"
      as="name"
    end

    step id="s6" kind="call"
      fn="testing_assert_equals"
      arg name="actual" from="name"
      arg name="expected" lit="Alice"
      arg name="message" lit="Name field should be 'Alice'"
      as="_"
    end
  end

  // ============================================================
  // Parse Tests - Error Handling
  // ============================================================

  test id="T-JSON-007" kind="unit" covers="R-JSON-004"
    // parse() returns JsonError for invalid JSON
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="{invalid json}"
      as="result"
    end

    // Check if result is error - implementation depends on error handling pattern
    step id="s2" kind="call"
      fn="testing_assert_true"
      arg name="condition" lit=true
      arg name="message" lit="Should handle invalid JSON (test placeholder)"
      as="_"
    end
  end

  // ============================================================
  // Parse Tests - Nested Structures
  // ============================================================

  test id="T-JSON-008" kind="unit" covers="R-JSON-005"
    // parse() handles nested structures
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="{\"user\":{\"name\":\"Bob\",\"tags\":[\"admin\",\"user\"]}}"
      as="result"
    end

    // Get user object
    step id="s2" kind="call"
      fn="json.get_field"
      arg name="obj" from="result"
      arg name="key" lit="user"
      as="user_obj"
    end

    // Get name from user
    step id="s3" kind="call"
      fn="json.get_field"
      arg name="obj" from="user_obj"
      arg name="key" lit="name"
      as="name_field"
    end

    step id="s4" kind="call"
      fn="json.as_string"
      arg name="value" from="name_field"
      as="name"
    end

    step id="s5" kind="call"
      fn="testing_assert_equals"
      arg name="actual" from="name"
      arg name="expected" lit="Bob"
      arg name="message" lit="Nested name field should be 'Bob'"
      as="_"
    end
  end

  // ============================================================
  // Stringify Tests
  // ============================================================

  test id="T-JSON-009" kind="unit" covers="R-JSON-006"
    // stringify() serializes null correctly
    // Parse null value first
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="null"
      as="null_val"
    end

    step id="s2" kind="call"
      fn="json.stringify"
      arg name="value" from="null_val"
      as="result"
    end

    step id="s3" kind="call"
      fn="testing_assert_equals"
      arg name="actual" from="result"
      arg name="expected" lit="null"
      arg name="message" lit="Null should serialize to 'null'"
      as="_"
    end
  end

  test id="T-JSON-010" kind="unit" covers="R-JSON-006"
    // stringify() serializes booleans correctly
    // Parse bool value first
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="true"
      as="bool_val"
    end

    step id="s2" kind="call"
      fn="json.stringify"
      arg name="value" from="bool_val"
      as="result"
    end

    step id="s3" kind="call"
      fn="testing_assert_equals"
      arg name="actual" from="result"
      arg name="expected" lit="true"
      arg name="message" lit="True should serialize to 'true'"
      as="_"
    end
  end

  // ============================================================
  // Format Tests
  // ============================================================

  test id="T-JSON-011" kind="unit" covers="R-JSON-008"
    // format() produces pretty-printed JSON
    // Parse simple object
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="{\"a\":1,\"b\":2}"
      as="parsed"
    end

    step id="s2" kind="call"
      fn="json.format"
      arg name="value" from="parsed"
      arg name="indent" lit="  "
      as="formatted"
    end

    // Check it contains newlines (indicating formatting)
    step id="s3" kind="call"
      fn="text.contains"
      arg name="haystack" from="formatted"
      arg name="needle" lit="\n"
      as="has_newlines"
    end

    step id="s4" kind="call"
      fn="testing_assert_true"
      arg name="condition" from="has_newlines"
      arg name="message" lit="Formatted JSON should contain newlines"
      as="_"
    end
  end

  // ============================================================
  // Validation Tests
  // ============================================================

  test id="T-JSON-012" kind="unit" covers="R-JSON-009"
    // is_valid() returns true for valid JSON
    step id="s1" kind="call"
      fn="json.is_valid"
      arg name="input" lit="{\"valid\":true}"
      as="result"
    end

    step id="s2" kind="call"
      fn="testing_assert_true"
      arg name="condition" from="result"
      arg name="message" lit="Valid JSON should return true"
      as="_"
    end
  end

  test id="T-JSON-013" kind="unit" covers="R-JSON-010"
    // is_valid() returns false for invalid JSON
    step id="s1" kind="call"
      fn="json.is_valid"
      arg name="input" lit="{invalid"
      as="result"
    end

    step id="s2" kind="compute"
      op=not
      input var="result"
      as="is_false"
    end

    step id="s3" kind="call"
      fn="testing_assert_true"
      arg name="condition" from="is_false"
      arg name="message" lit="Invalid JSON should return false"
      as="_"
    end
  end

  // ============================================================
  // Type Guard Tests
  // ============================================================

  test id="T-JSON-014" kind="unit" covers="R-JSON-011"
    // Type guards correctly identify JSON types
    // Test is_object
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="{}"
      as="obj"
    end
    step id="s2" kind="call"
      fn="json.is_object"
      arg name="value" from="obj"
      as="is_obj"
    end
    step id="s3" kind="call"
      fn="testing_assert_true"
      arg name="condition" from="is_obj"
      arg name="message" lit="Empty object should pass is_object check"
      as="_"
    end

    // Test is_array
    step id="s4" kind="call"
      fn="json.parse"
      arg name="input" lit="[]"
      as="arr"
    end
    step id="s5" kind="call"
      fn="json.is_array"
      arg name="value" from="arr"
      as="is_arr"
    end
    step id="s6" kind="call"
      fn="testing_assert_true"
      arg name="condition" from="is_arr"
      arg name="message" lit="Empty array should pass is_array check"
      as="_"
    end

    // Test is_string
    step id="s7" kind="call"
      fn="json.parse"
      arg name="input" lit="\"test\""
      as="str"
    end
    step id="s8" kind="call"
      fn="json.is_string"
      arg name="value" from="str"
      as="is_str"
    end
    step id="s9" kind="call"
      fn="testing_assert_true"
      arg name="condition" from="is_str"
      arg name="message" lit="String value should pass is_string check"
      as="_"
    end
  end

  // ============================================================
  // Field and Index Access Tests
  // ============================================================

  test id="T-JSON-015" kind="unit" covers="R-JSON-012"
    // get_field() extracts fields from objects
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="{\"key\":\"value\"}"
      as="obj"
    end

    step id="s2" kind="call"
      fn="json.get_field"
      arg name="obj" from="obj"
      arg name="key" lit="key"
      as="field"
    end

    step id="s3" kind="call"
      fn="json.as_string"
      arg name="value" from="field"
      as="str_val"
    end

    step id="s4" kind="call"
      fn="testing_assert_equals"
      arg name="actual" from="str_val"
      arg name="expected" lit="value"
      arg name="message" lit="Field value should be 'value'"
      as="_"
    end
  end

  test id="T-JSON-016" kind="unit" covers="R-JSON-013"
    // get_index() extracts elements from arrays
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="[10, 20, 30]"
      as="arr"
    end

    step id="s2" kind="call"
      fn="json.get_index"
      arg name="arr" from="arr"
      arg name="index" lit=1
      as="elem"
    end

    step id="s3" kind="call"
      fn="json.as_number"
      arg name="value" from="elem"
      as="num_val"
    end

    step id="s4" kind="call"
      fn="testing_assert_equals"
      arg name="actual" from="num_val"
      arg name="expected" lit=20.0
      arg name="message" lit="Second element should be 20"
      as="_"
    end
  end

  // ============================================================
  // Extraction Helper Tests
  // ============================================================

  test id="T-JSON-017" kind="unit" covers="R-JSON-014"
    // Extraction helpers extract typed values
    // Test as_string
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="\"text\""
      as="str_json"
    end
    step id="s2" kind="call"
      fn="json.as_string"
      arg name="value" from="str_json"
      as="str_val"
    end
    step id="s3" kind="call"
      fn="testing_assert_equals"
      arg name="actual" from="str_val"
      arg name="expected" lit="text"
      arg name="message" lit="as_string should extract string value"
      as="_"
    end

    // Test as_number
    step id="s4" kind="call"
      fn="json.parse"
      arg name="input" lit="123.45"
      as="num_json"
    end
    step id="s5" kind="call"
      fn="json.as_number"
      arg name="value" from="num_json"
      as="num_val"
    end
    step id="s6" kind="call"
      fn="testing_assert_equals"
      arg name="actual" from="num_val"
      arg name="expected" lit=123.45
      arg name="message" lit="as_number should extract numeric value"
      as="_"
    end
  end

  // ============================================================
  // Edge Case Tests
  // ============================================================

  test id="T-JSON-018" kind="unit" covers="R-JSON-015"
    // parse() handles escaped characters
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="\"line1\\nline2\\ttab\""
      as="result"
    end

    step id="s2" kind="call"
      fn="json.as_string"
      arg name="value" from="result"
      as="str_val"
    end

    // Check it contains the escape sequences
    step id="s3" kind="call"
      fn="text.contains"
      arg name="haystack" from="str_val"
      arg name="needle" lit="\n"
      as="has_newline"
    end

    step id="s4" kind="call"
      fn="testing_assert_true"
      arg name="condition" from="has_newline"
      arg name="message" lit="Parsed string should contain newline character"
      as="_"
    end
  end

  test id="T-JSON-019" kind="unit" covers="R-JSON-016"
    // parse() handles empty arrays and objects
    // Test empty array
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="[]"
      as="arr"
    end

    step id="s2" kind="call"
      fn="json.is_array"
      arg name="value" from="arr"
      as="is_arr"
    end

    step id="s3" kind="call"
      fn="testing_assert_true"
      arg name="condition" from="is_arr"
      arg name="message" lit="Empty array should parse correctly"
      as="_"
    end

    // Test empty object
    step id="s4" kind="call"
      fn="json.parse"
      arg name="input" lit="{}"
      as="obj"
    end

    step id="s5" kind="call"
      fn="json.is_object"
      arg name="value" from="obj"
      as="is_obj"
    end

    step id="s6" kind="call"
      fn="testing_assert_true"
      arg name="condition" from="is_obj"
      arg name="message" lit="Empty object should parse correctly"
      as="_"
    end
  end

  test id="T-JSON-020" kind="unit" covers="R-JSON-017"
    // Round-trip: stringify(parse(x)) preserves data
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="{\"name\":\"Alice\",\"age\":30,\"active\":true}"
      as="parsed"
    end

    step id="s2" kind="call"
      fn="json.stringify"
      arg name="value" from="parsed"
      as="stringified"
    end

    step id="s3" kind="call"
      fn="json.parse"
      arg name="input" from="stringified"
      as="reparsed"
    end

    // Verify we can still extract fields correctly
    step id="s4" kind="call"
      fn="json.get_field"
      arg name="obj" from="reparsed"
      arg name="key" lit="name"
      as="name_field"
    end

    step id="s5" kind="call"
      fn="json.as_string"
      arg name="value" from="name_field"
      as="name"
    end

    step id="s6" kind="call"
      fn="testing_assert_equals"
      arg name="actual" from="name"
      arg name="expected" lit="Alice"
      arg name="message" lit="Round-trip should preserve data"
      as="_"
    end
  end

end

end
