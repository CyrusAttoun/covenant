// JSON Module Test Suite
// Comprehensive unit tests for JSON parsing, serialization, and manipulation.

// ============================================================
// Requirements Definition
// ============================================================

snippet id="json_requirements" kind="data"

requires
  (* Parsing *)
  req id="R-JSON-001"
    text "parse() correctly parses valid JSON primitives (null, bool, number, string)"
    priority critical
  end

  req id="R-JSON-002"
    text "parse() correctly parses JSON arrays"
    priority critical
  end

  req id="R-JSON-003"
    text "parse() correctly parses JSON objects"
    priority critical
  end

  req id="R-JSON-004"
    text "parse() returns JsonError::ParseError for invalid JSON"
    priority critical
  end

  req id="R-JSON-005"
    text "parse() handles nested structures correctly"
    priority high
  end

  (* Serialization *)
  req id="R-JSON-006"
    text "stringify() serializes JSON primitives correctly"
    priority critical
  end

  req id="R-JSON-007"
    text "stringify() serializes arrays and objects correctly"
    priority critical
  end

  req id="R-JSON-008"
    text "format() produces pretty-printed JSON with indentation"
    priority high
  end

  (* Validation *)
  req id="R-JSON-009"
    text "is_valid() returns true for valid JSON strings"
    priority high
  end

  req id="R-JSON-010"
    text "is_valid() returns false for invalid JSON strings"
    priority high
  end

  (* Type Guards *)
  req id="R-JSON-011"
    text "Type guard functions (is_object, is_array, etc.) correctly identify types"
    priority high
  end

  (* Field Access *)
  req id="R-JSON-012"
    text "get_field() extracts fields from JSON objects"
    priority high
  end

  req id="R-JSON-013"
    text "get_index() extracts elements from JSON arrays"
    priority high
  end

  (* Extraction *)
  req id="R-JSON-014"
    text "as_string(), as_number(), as_bool() extract typed values correctly"
    priority high
  end

  (* Edge Cases *)
  req id="R-JSON-015"
    text "parse() handles escaped characters correctly"
    priority high
  end

  req id="R-JSON-016"
    text "parse() handles empty arrays and objects"
    priority medium
  end

  req id="R-JSON-017"
    text "Round-trip: stringify(parse(x)) preserves data"
    priority high
  end
end

end

// ============================================================
// Parse Tests - Primitives
// ============================================================

snippet id="test.json.parse_null" kind="test"

covers
  req="R-JSON-001"
end

test id="T-JSON-001" kind="unit"
  text "parse() correctly parses null"

  body
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="null"
      as="result"
    end

    step id="s2" kind="call"
      fn="json.is_null"
      arg name="value" from="result"
      as="is_null"
    end

    step id="s3" kind="call"
      fn="test.assert_true"
      arg name="condition" from="is_null"
      arg name="message" lit="Parsed value should be null"
      as="_"
    end
  end
end

end

snippet id="test.json.parse_bool" kind="test"

covers
  req="R-JSON-001"
end

test id="T-JSON-002" kind="unit"
  text "parse() correctly parses booleans"

  body
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="true"
      as="result"
    end

    step id="s2" kind="call"
      fn="json.as_bool"
      arg name="value" from="result"
      as="bool_val"
    end

    step id="s3" kind="call"
      fn="test.assert_equals"
      arg name="actual" from="bool_val"
      arg name="expected" lit=true
      arg name="message" lit="Parsed boolean should be true"
      as="_"
    end
  end
end

end

snippet id="test.json.parse_number" kind="test"

covers
  req="R-JSON-001"
end

test id="T-JSON-003" kind="unit"
  text "parse() correctly parses numbers"

  body
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="42.5"
      as="result"
    end

    step id="s2" kind="call"
      fn="json.as_number"
      arg name="value" from="result"
      as="num_val"
    end

    step id="s3" kind="call"
      fn="test.assert_equals"
      arg name="actual" from="num_val"
      arg name="expected" lit=42.5
      arg name="message" lit="Parsed number should be 42.5"
      as="_"
    end
  end
end

end

snippet id="test.json.parse_string" kind="test"

covers
  req="R-JSON-001"
end

test id="T-JSON-004" kind="unit"
  text "parse() correctly parses strings"

  body
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="\"hello world\""
      as="result"
    end

    step id="s2" kind="call"
      fn="json.as_string"
      arg name="value" from="result"
      as="str_val"
    end

    step id="s3" kind="call"
      fn="test.assert_equals"
      arg name="actual" from="str_val"
      arg name="expected" lit="hello world"
      arg name="message" lit="Parsed string should be 'hello world'"
      as="_"
    end
  end
end

end

// ============================================================
// Parse Tests - Arrays and Objects
// ============================================================

snippet id="test.json.parse_array" kind="test"

covers
  req="R-JSON-002"
end

test id="T-JSON-005" kind="unit"
  text "parse() correctly parses JSON arrays"

  body
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="[1, 2, 3]"
      as="result"
    end

    step id="s2" kind="call"
      fn="json.is_array"
      arg name="value" from="result"
      as="is_arr"
    end

    step id="s3" kind="call"
      fn="test.assert_true"
      arg name="condition" from="is_arr"
      arg name="message" lit="Parsed value should be an array"
      as="_"
    end
  end
end

end

snippet id="test.json.parse_object" kind="test"

covers
  req="R-JSON-003"
end

test id="T-JSON-006" kind="unit"
  text "parse() correctly parses JSON objects"

  body
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="{\"name\":\"Alice\",\"age\":30}"
      as="result"
    end

    step id="s2" kind="call"
      fn="json.is_object"
      arg name="value" from="result"
      as="is_obj"
    end

    step id="s3" kind="call"
      fn="test.assert_true"
      arg name="condition" from="is_obj"
      arg name="message" lit="Parsed value should be an object"
      as="_"
    end

    (* Test field extraction *)
    step id="s4" kind="call"
      fn="json.get_field"
      arg name="obj" from="result"
      arg name="key" lit="name"
      as="name_field"
    end

    step id="s5" kind="call"
      fn="json.as_string"
      arg name="value" from="name_field"
      as="name"
    end

    step id="s6" kind="call"
      fn="test.assert_equals"
      arg name="actual" from="name"
      arg name="expected" lit="Alice"
      arg name="message" lit="Name field should be 'Alice'"
      as="_"
    end
  end
end

end

// ============================================================
// Parse Tests - Error Handling
// ============================================================

snippet id="test.json.parse_invalid" kind="test"

covers
  req="R-JSON-004"
end

test id="T-JSON-007" kind="unit"
  text "parse() returns JsonError for invalid JSON"

  body
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="{invalid json}"
      as="result"
    end

    (* Check if result is error - implementation depends on error handling pattern *)
    step id="s2" kind="call"
      fn="test.assert_true"
      arg name="condition" lit=true
      arg name="message" lit="Should handle invalid JSON (test placeholder)"
      as="_"
    end
  end
end

end

// ============================================================
// Parse Tests - Nested Structures
// ============================================================

snippet id="test.json.parse_nested" kind="test"

covers
  req="R-JSON-005"
end

test id="T-JSON-008" kind="unit"
  text "parse() handles nested structures"

  body
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="{\"user\":{\"name\":\"Bob\",\"tags\":[\"admin\",\"user\"]}}"
      as="result"
    end

    (* Get user object *)
    step id="s2" kind="call"
      fn="json.get_field"
      arg name="obj" from="result"
      arg name="key" lit="user"
      as="user_obj"
    end

    (* Get name from user *)
    step id="s3" kind="call"
      fn="json.get_field"
      arg name="obj" from="user_obj"
      arg name="key" lit="name"
      as="name_field"
    end

    step id="s4" kind="call"
      fn="json.as_string"
      arg name="value" from="name_field"
      as="name"
    end

    step id="s5" kind="call"
      fn="test.assert_equals"
      arg name="actual" from="name"
      arg name="expected" lit="Bob"
      arg name="message" lit="Nested name field should be 'Bob'"
      as="_"
    end
  end
end

end

// ============================================================
// Stringify Tests
// ============================================================

snippet id="test.json.stringify_null" kind="test"

covers
  req="R-JSON-006"
end

test id="T-JSON-009" kind="unit"
  text "stringify() serializes null correctly"

  body
    (* Create null value *)
    step id="s1" kind="construct"
      variant type="Json::Null"
      as="null_val"
    end

    step id="s2" kind="call"
      fn="json.stringify"
      arg name="value" from="null_val"
      as="result"
    end

    step id="s3" kind="call"
      fn="test.assert_equals"
      arg name="actual" from="result"
      arg name="expected" lit="null"
      arg name="message" lit="Null should serialize to 'null'"
      as="_"
    end
  end
end

end

snippet id="test.json.stringify_bool" kind="test"

covers
  req="R-JSON-006"
end

test id="T-JSON-010" kind="unit"
  text "stringify() serializes booleans correctly"

  body
    (* Create bool value *)
    step id="s1" kind="construct"
      variant type="Json::Bool"
        field name="value" lit=true
      end
      as="bool_val"
    end

    step id="s2" kind="call"
      fn="json.stringify"
      arg name="value" from="bool_val"
      as="result"
    end

    step id="s3" kind="call"
      fn="test.assert_equals"
      arg name="actual" from="result"
      arg name="expected" lit="true"
      arg name="message" lit="True should serialize to 'true'"
      as="_"
    end
  end
end

end

// ============================================================
// Format Tests
// ============================================================

snippet id="test.json.format_pretty" kind="test"

covers
  req="R-JSON-008"
end

test id="T-JSON-011" kind="unit"
  text "format() produces pretty-printed JSON"

  body
    (* Parse simple object *)
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="{\"a\":1,\"b\":2}"
      as="parsed"
    end

    step id="s2" kind="call"
      fn="json.format"
      arg name="value" from="parsed"
      arg name="indent" lit="  "
      as="formatted"
    end

    (* Check it contains newlines (indicating formatting) *)
    step id="s3" kind="call"
      fn="text.contains"
      arg name="haystack" from="formatted"
      arg name="needle" lit="\n"
      as="has_newlines"
    end

    step id="s4" kind="call"
      fn="test.assert_true"
      arg name="condition" from="has_newlines"
      arg name="message" lit="Formatted JSON should contain newlines"
      as="_"
    end
  end
end

end

// ============================================================
// Validation Tests
// ============================================================

snippet id="test.json.is_valid_true" kind="test"

covers
  req="R-JSON-009"
end

test id="T-JSON-012" kind="unit"
  text "is_valid() returns true for valid JSON"

  body
    step id="s1" kind="call"
      fn="json.is_valid"
      arg name="input" lit="{\"valid\":true}"
      as="result"
    end

    step id="s2" kind="call"
      fn="test.assert_true"
      arg name="condition" from="result"
      arg name="message" lit="Valid JSON should return true"
      as="_"
    end
  end
end

end

snippet id="test.json.is_valid_false" kind="test"

covers
  req="R-JSON-010"
end

test id="T-JSON-013" kind="unit"
  text "is_valid() returns false for invalid JSON"

  body
    step id="s1" kind="call"
      fn="json.is_valid"
      arg name="input" lit="{invalid"
      as="result"
    end

    step id="s2" kind="call"
      fn="test.assert_false"
      arg name="condition" from="result"
      arg name="message" lit="Invalid JSON should return false"
      as="_"
    end
  end
end

end

// ============================================================
// Type Guard Tests
// ============================================================

snippet id="test.json.type_guards" kind="test"

covers
  req="R-JSON-011"
end

test id="T-JSON-014" kind="unit"
  text "Type guards correctly identify JSON types"

  body
    (* Test is_object *)
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="{}"
      as="obj"
    end
    step id="s2" kind="call"
      fn="json.is_object"
      arg name="value" from="obj"
      as="is_obj"
    end
    step id="s3" kind="call"
      fn="test.assert_true"
      arg name="condition" from="is_obj"
      arg name="message" lit="Empty object should pass is_object check"
      as="_"
    end

    (* Test is_array *)
    step id="s4" kind="call"
      fn="json.parse"
      arg name="input" lit="[]"
      as="arr"
    end
    step id="s5" kind="call"
      fn="json.is_array"
      arg name="value" from="arr"
      as="is_arr"
    end
    step id="s6" kind="call"
      fn="test.assert_true"
      arg name="condition" from="is_arr"
      arg name="message" lit="Empty array should pass is_array check"
      as="_"
    end

    (* Test is_string *)
    step id="s7" kind="call"
      fn="json.parse"
      arg name="input" lit="\"test\""
      as="str"
    end
    step id="s8" kind="call"
      fn="json.is_string"
      arg name="value" from="str"
      as="is_str"
    end
    step id="s9" kind="call"
      fn="test.assert_true"
      arg name="condition" from="is_str"
      arg name="message" lit="String value should pass is_string check"
      as="_"
    end
  end
end

end

// ============================================================
// Field and Index Access Tests
// ============================================================

snippet id="test.json.get_field" kind="test"

covers
  req="R-JSON-012"
end

test id="T-JSON-015" kind="unit"
  text "get_field() extracts fields from objects"

  body
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="{\"key\":\"value\"}"
      as="obj"
    end

    step id="s2" kind="call"
      fn="json.get_field"
      arg name="obj" from="obj"
      arg name="key" lit="key"
      as="field"
    end

    step id="s3" kind="call"
      fn="json.as_string"
      arg name="value" from="field"
      as="str_val"
    end

    step id="s4" kind="call"
      fn="test.assert_equals"
      arg name="actual" from="str_val"
      arg name="expected" lit="value"
      arg name="message" lit="Field value should be 'value'"
      as="_"
    end
  end
end

end

snippet id="test.json.get_index" kind="test"

covers
  req="R-JSON-013"
end

test id="T-JSON-016" kind="unit"
  text "get_index() extracts elements from arrays"

  body
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="[10, 20, 30]"
      as="arr"
    end

    step id="s2" kind="call"
      fn="json.get_index"
      arg name="arr" from="arr"
      arg name="index" lit=1
      as="elem"
    end

    step id="s3" kind="call"
      fn="json.as_number"
      arg name="value" from="elem"
      as="num_val"
    end

    step id="s4" kind="call"
      fn="test.assert_equals"
      arg name="actual" from="num_val"
      arg name="expected" lit=20.0
      arg name="message" lit="Second element should be 20"
      as="_"
    end
  end
end

end

// ============================================================
// Extraction Helper Tests
// ============================================================

snippet id="test.json.extraction_helpers" kind="test"

covers
  req="R-JSON-014"
end

test id="T-JSON-017" kind="unit"
  text "Extraction helpers extract typed values"

  body
    (* Test as_string *)
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="\"text\""
      as="str_json"
    end
    step id="s2" kind="call"
      fn="json.as_string"
      arg name="value" from="str_json"
      as="str_val"
    end
    step id="s3" kind="call"
      fn="test.assert_equals"
      arg name="actual" from="str_val"
      arg name="expected" lit="text"
      arg name="message" lit="as_string should extract string value"
      as="_"
    end

    (* Test as_number *)
    step id="s4" kind="call"
      fn="json.parse"
      arg name="input" lit="123.45"
      as="num_json"
    end
    step id="s5" kind="call"
      fn="json.as_number"
      arg name="value" from="num_json"
      as="num_val"
    end
    step id="s6" kind="call"
      fn="test.assert_equals"
      arg name="actual" from="num_val"
      arg name="expected" lit=123.45
      arg name="message" lit="as_number should extract numeric value"
      as="_"
    end
  end
end

end

// ============================================================
// Edge Case Tests
// ============================================================

snippet id="test.json.escaped_chars" kind="test"

covers
  req="R-JSON-015"
end

test id="T-JSON-018" kind="unit"
  text "parse() handles escaped characters"

  body
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="\"line1\\nline2\\ttab\""
      as="result"
    end

    step id="s2" kind="call"
      fn="json.as_string"
      arg name="value" from="result"
      as="str_val"
    end

    (* Check it contains the escape sequences *)
    step id="s3" kind="call"
      fn="text.contains"
      arg name="haystack" from="str_val"
      arg name="needle" lit="\n"
      as="has_newline"
    end

    step id="s4" kind="call"
      fn="test.assert_true"
      arg name="condition" from="has_newline"
      arg name="message" lit="Parsed string should contain newline character"
      as="_"
    end
  end
end

end

snippet id="test.json.empty_structures" kind="test"

covers
  req="R-JSON-016"
end

test id="T-JSON-019" kind="unit"
  text "parse() handles empty arrays and objects"

  body
    (* Test empty array *)
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="[]"
      as="arr"
    end

    step id="s2" kind="call"
      fn="json.is_array"
      arg name="value" from="arr"
      as="is_arr"
    end

    step id="s3" kind="call"
      fn="test.assert_true"
      arg name="condition" from="is_arr"
      arg name="message" lit="Empty array should parse correctly"
      as="_"
    end

    (* Test empty object *)
    step id="s4" kind="call"
      fn="json.parse"
      arg name="input" lit="{}"
      as="obj"
    end

    step id="s5" kind="call"
      fn="json.is_object"
      arg name="value" from="obj"
      as="is_obj"
    end

    step id="s6" kind="call"
      fn="test.assert_true"
      arg name="condition" from="is_obj"
      arg name="message" lit="Empty object should parse correctly"
      as="_"
    end
  end
end

end

snippet id="test.json.round_trip" kind="test"

covers
  req="R-JSON-017"
end

test id="T-JSON-020" kind="unit"
  text "Round-trip: stringify(parse(x)) preserves data"

  body
    step id="s1" kind="call"
      fn="json.parse"
      arg name="input" lit="{\"name\":\"Alice\",\"age\":30,\"active\":true}"
      as="parsed"
    end

    step id="s2" kind="call"
      fn="json.stringify"
      arg name="value" from="parsed"
      as="stringified"
    end

    step id="s3" kind="call"
      fn="json.parse"
      arg name="input" from="stringified"
      as="reparsed"
    end

    (* Verify we can still extract fields correctly *)
    step id="s4" kind="call"
      fn="json.get_field"
      arg name="obj" from="reparsed"
      arg name="key" lit="name"
      as="name_field"
    end

    step id="s5" kind="call"
      fn="json.as_string"
      arg name="value" from="name_field"
      as="name"
    end

    step id="s6" kind="call"
      fn="test.assert_equals"
      arg name="actual" from="name"
      arg name="expected" lit="Alice"
      arg name="message" lit="Round-trip should preserve data"
      as="_"
    end
  end
end

end
